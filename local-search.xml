<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>详解HashMap</title>
    <link href="/2025/04/14/%E8%AF%A6%E8%A7%A3HashMap/"/>
    <url>/2025/04/14/%E8%AF%A6%E8%A7%A3HashMap/</url>
    
    <content type="html"><![CDATA[<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><h3 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h3><p>HashMap的底层数据结构是数组和链表。</p><p>key 的 <code>hashcode</code> 经过二次哈希处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>二次哈希用来优化哈希值的分布，通过对原始的 <code>hashCode()</code> 进行额外处理，二次哈希可以减小哈希碰撞，从而提高数据的分布均匀性。</p><h3 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h3><p>HashMap的底层数据结构是数组、链表和红黑树。</p><p>如果当前数组长度大于等于64，且链表长度大于阈值（默认为 8）时，将链表转化为红黑树；如果数组长度没到64，则会进行扩容。数组扩容能减少哈希冲突的发生概率（即将元素重新分散到新的、更大的数组中），这在多数情况下比直接转换为红黑树更高效。</p><p>而且，转化为红黑树目的是减少搜索时间，但是红黑树需要保持自平衡，维护成本较高，因此过早引入红黑树反而会增加复杂度，花费更多的时间。</p><h3 id="数组的长度为什么一定是2的x次方"><a href="#数组的长度为什么一定是2的x次方" class="headerlink" title="数组的长度为什么一定是2的x次方"></a>数组的长度为什么一定是2的x次方</h3><p>因为hash值的范围是-2147483648 ~ 2147483647，这个范围过大，因此需要让hash值对数组的长度取模运算得到的余数作为存放的位置（数组下标），但是取余(%)操作是复杂的。</p><p>如果取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&amp;)操作，换句话说，<code>hash % n == hash &amp; (n-1)</code> 的充要条件是 n 是 2 的 x 次方。而与(&amp;)操作是比取余操作简单很多的，所付出的代价很小，效率更高。因此，数组长度选用了2的x次方。</p><p>除此之外，长度是 2 的幂次方，可以让 HashMap 在扩容的时候更均匀。而且，扩容机制也变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。</p><h2 id="为什么HashMap线程不安全"><a href="#为什么HashMap线程不安全" class="headerlink" title="为什么HashMap线程不安全"></a>为什么HashMap线程不安全</h2><p>HashMap线程不安全主要体现在因为在多线程的情况下，HashMap会发生死循环和数据丢失问题。</p><h3 id="死循环"><a href="#死循环" class="headerlink" title="死循环"></a>死循环</h3><p>死循环问题发生在JDK1.8之前的HashMap，当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>JDK1.8将头插法替换为了尾插法，从而避免了死循环问题。</p><h3 id="数据丢失"><a href="#数据丢失" class="headerlink" title="数据丢失"></a>数据丢失</h3><p>两个线程 1,2 同时进行 put 操作，并且发生了哈希冲突（hash 函数计算出的插入下标是相同的）。不同的线程可能在不同的时间片获得 CPU 执行的机会，当前线程 1 执行完哈希冲突判断后，由于时间片耗尽挂起。线程 2 先完成了插入操作。随后，线程 1 获得时间片，由于之前已经进行过 hash 碰撞的判断，所有此时会直接进行插入，这就导致线程 2 插入的数据被线程 1 覆盖了。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道操作系统面试题</title>
    <link href="/2025/04/14/%E4%B8%A4%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%204.14/"/>
    <url>/2025/04/14/%E4%B8%A4%E9%81%93%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%204.14/</url>
    
    <content type="html"><![CDATA[<h2 id="死锁及其产生的原因是什么？"><a href="#死锁及其产生的原因是什么？" class="headerlink" title="死锁及其产生的原因是什么？"></a>死锁及其产生的原因是什么？</h2><p><strong>死锁</strong>是这样的一种情况：<strong>多个进程&#x2F;线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放</strong>。由于进程&#x2F;线程被无限期地阻塞，因此程序不可能正常终止。</p><p>死锁的产生有四个<strong>必要条件</strong>：</p><ol><li><strong>互斥</strong>：资源是非共享的，一个资源一次只能给一个进程&#x2F;线程使用，如果一个资源正在被使用，另一个进程&#x2F;线程想要使用这个资源，就必须等待，直到该资源被释放</li><li><strong>占有并等待</strong>：一个进程&#x2F;线程至少应该占有一个资源，并等待另一资源，而该资源被其他进程&#x2F;线程所占有</li><li><strong>非抢占</strong>：资源不能被抢占，只能由持有该资源的进程&#x2F;线程主动释放</li><li><strong>循环等待</strong>：一组等待资源的进程&#x2F;线程，各自等待的资源是其他进程&#x2F;线程所持有的</li></ol><p>只要破坏了以上任意一个条件，死锁就不会发生。</p><h2 id="对I-O模型的了解"><a href="#对I-O模型的了解" class="headerlink" title="对I&#x2F;O模型的了解"></a>对I&#x2F;O模型的了解</h2><ul><li><strong>阻塞I&#x2F;O模型</strong>：应用程序发起I&#x2F;O操作后会被阻塞，直到操作完成才返回结果。适用于对实时性要求不高的场景。</li><li><strong>非阻塞I&#x2F;O模型</strong>：应用程序发起I&#x2F;O操作后立即返回，不会被阻塞，但需要不断轮询或者使用系统调用来检查I&#x2F;O操作是否完成。适合于需要进行多路复用的场景，例如需要同时处理多个socket连接的服务器程序。</li><li><strong>I&#x2F;O复用模型</strong>：通过系统调用，应用程序同时等待多个I&#x2F;O操作，当其中任何一个I&#x2F;O操作准备就绪时，应用程序会被通知。适合于需要同时处理多个I&#x2F;O操作的场景，比如高并发的服务端程序。</li><li><strong>信号驱动I&#x2F;O模型</strong>：应用程序发起I&#x2F;O操作后，可以继续做其他事情，当I&#x2F;O操作完成时，操作系统会向应用程序发送信号来通知其完成。适合于需要异步I&#x2F;O通知的场景，可以提高系统的并发能力。</li><li><strong>异步I&#x2F;O模型</strong>：应用程序发起I&#x2F;O操作后可以立即做其他事情，当I&#x2F;O操作完成时，应用程序会得到通知。异步I&#x2F;O模型由操作系统内核完成I&#x2F;O操作，应用程序只需等待通知即可。适合于需要大量并发连接和高性能的场景，能够减少系统调用次数，提高系统效率。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道计算机网络面试题</title>
    <link href="/2025/04/14/%E4%B8%A4%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%204.14/"/>
    <url>/2025/04/14/%E4%B8%A4%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%204.14/</url>
    
    <content type="html"><![CDATA[<h2 id="TLS四次握手的过程"><a href="#TLS四次握手的过程" class="headerlink" title="TLS四次握手的过程"></a>TLS四次握手的过程</h2><h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>首先，客户端向服务端发送加密通信请求，这个请求主要包含三个部分：</p><ol><li>客户端支持的 <strong>TLS 协议版本</strong></li><li>客户端生成的一个<strong>随机数</strong>，这个随机数将会<strong>参与生成 “会话密钥”</strong></li><li>客户端支持的<strong>密码套件列表</strong>，如 RSA 加密算法</li></ol><h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>服务器收到客户端请求后，向客户端发出响应，主要包含四个部分：</p><ol><li>确认 <strong>TLS 协议版本</strong>，如果<strong>浏览器不支持，则关闭加密通信</strong></li><li>服务端生成的一个<strong>随机数</strong>，这个随机数将会<strong>参与生成 “会话密钥”</strong></li><li>服务端支持的<strong>密码套件列表</strong>，如 RSA 加密算法</li><li>服务器的<strong>数字证书</strong></li></ol><h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 <strong>CA 公钥</strong>，<strong>确认服务器的数字证书的真实性</strong>。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><ol><li>一个随机数（第三个随机数），这个随机数将会<strong>参与生成 “会话密钥”</strong>，且该随机数会<strong>被服务器公钥加密</strong></li><li><strong>将加密通信算法改变的通知</strong>，告诉服务端<strong>随后的信息都将用会话秘钥加密通信</strong></li><li><strong>客户端握手结束通知</strong>，表示客户端的握手阶段已经结束，同时<strong>把之前所有内容的发送的数据做个摘要，用来供服务端校验</strong></li></ol><p><em>在第三次握手后，通信双方确定了加密算法和三个随机数，因此可以分别生成同样的会话密钥</em></p><h3 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h3><p>服务端将第三个随机数用服务器私钥解密，并计算出会话密钥后，向客户端发送以下信息：</p><ol><li><strong>将加密通信算法改变的通知</strong>，告诉客户端<strong>随后的信息都将用会话秘钥加密通信</strong></li><li><strong>服务端握手结束通知</strong>，表示服务端的握手阶段已经结束，同时<strong>把之前所有内容的发送的数据做个摘要，用来供客户端校验</strong></li></ol><p>接下来双方就可以用会话密钥来加密通信啦！</p><h2 id="HTTP和RPC的区别"><a href="#HTTP和RPC的区别" class="headerlink" title="HTTP和RPC的区别"></a>HTTP和RPC的区别</h2><ul><li><strong>HTTP是协议，而RPC不是协议，而是一种调用方式</strong>，其具体实现，比如gRPC等，才是实现了RPC调用的协议。<strong>PRC存在的目的是希望程序员能像调用本地方法那样来调用远端的服务方法</strong>。</li><li><strong>RPC 有很多种实现方式，不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 B&#x2F;S 架构，而 RPC 更多用于 C&#x2F;S 架构</strong>。但现在其实已经没分那么清了，B&#x2F;S 和 C&#x2F;S 在慢慢融合。很多软件同时支持多端，所以<strong>对外一般用 HTTP 协议</strong>，而<strong>内部集群的微服务之间则采用 RPC</strong> 进行通讯。</li><li><strong>RPC 出现更早，且比目前主流的 HTTP&#x2F;1.1 性能要更好</strong>，所以大部分公司内部都还在使用 RPC。但是<strong>HTTP&#x2F;2.0在 HTTP&#x2F;1.1的基础上做了优化，性能可能比很多 RPC 协议都要好</strong>，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道常见的mysql面试题 4.10</title>
    <link href="/2025/04/10/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84mysql%E9%9D%A2%E8%AF%95%E9%A2%98%204.10/"/>
    <url>/2025/04/10/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84mysql%E9%9D%A2%E8%AF%95%E9%A2%98%204.10/</url>
    
    <content type="html"><![CDATA[<h2 id="事务的4个特性（ACID）"><a href="#事务的4个特性（ACID）" class="headerlink" title="事务的4个特性（ACID）"></a>事务的4个特性（ACID）</h2><ul><li><p><strong>原子性（A）</strong>：事务是最小的执行单位，不可以被分割，动作要么全部完成，要么完全不起作用。</p></li><li><p><strong>一致性（C）</strong>：执行事务前后，数据保持一致。比如转账事务中，不论事务是否成功，转账者和收款人钱的总额是不变的。</p></li><li><p><strong>隔离性（I）</strong>：并发访问数据库时，一个用户的事务不会被其他事务所干扰，各个并发事务之间，数据库是相互独立的。</p></li><li><p><strong>持久性（D）</strong>：一个事务被提交后，它对数据库的影响是持久的，即使数据库发生故障也不应该对其有影响。</p></li></ul><p>事务的原子性、隔离性、持久性是为了保证事务的一致性。</p><h2 id="事务的4种隔离级别"><a href="#事务的4种隔离级别" class="headerlink" title="事务的4种隔离级别"></a>事务的4种隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED（读未提交）</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、不可重复读和幻读。</li><li><strong>READ-COMMITTED（读已提交）</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是不可重复读和幻读仍有可能发生。</li><li><strong>REPEATABLE-READ（可重复读）</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>**SERIALIZABLE(串行化)**：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>这里补充脏读、不可重复读和幻读：</p><ul><li><strong>脏读</strong>：读取其他事务尚未提交的数据变更</li><li><strong>不可重复读</strong>：在同一事务中，对非自己修改的数据的两次读取结果不同</li><li><strong>幻读</strong>：在一个事务读取了几行数据，接着另一个并发事务插入了一些数据，在随后的查询中，第一个事务就会发现多了一些原本不存在的记录</li></ul><p>在可重复读的隔离级别下，是可以解决一部分幻读问题的：</p><ul><li>给事务操作的这张表添加表锁或者 <code>Next-key Lock</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道常见的操作系统面试题 4.9</title>
    <link href="/2025/04/09/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%204.9/"/>
    <url>/2025/04/09/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98%204.9/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程的区别是什么？"><a href="#进程和线程的区别是什么？" class="headerlink" title="进程和线程的区别是什么？"></a>进程和线程的区别是什么？</h2><ul><li><strong>本质方面</strong>，进程是操作系统进行资源分配的基本单位；线程是任务调度和执行的基本单位</li><li><strong>在切换开销方面</strong>，每个进程都有独立的代码和数据空间（程序上下文），进程之间的切换会有较大的开销；线程可以看做轻量级的进程，一个进程中的线程之间共享代码和堆空间，同一进程中的线程的切换，只需要切换运行栈和程序计数器，开销较小‘</li><li><strong>在稳定性方面</strong>，如果一个进程崩溃了，往往不会影响其他进程及其兄弟进程和父进程；如果一个线程崩溃了，会影响到所在的整个进程</li><li><strong>内存分配方面</strong>：系统在运行的时候会为每个进程分配不同的内存空间；对线程而言，除了CPU外，系统不会为其分配内存，线程所使用的资源来自其所属进程的资源，同一进程中的线程之间只能共享资源</li><li><strong>包含关系</strong>：一个进程中可以包含多个线程；一个线程会属于一个进程</li></ul><h2 id="进程间的通信方式（IPC）有哪些？"><a href="#进程间的通信方式（IPC）有哪些？" class="headerlink" title="进程间的通信方式（IPC）有哪些？"></a>进程间的通信方式（IPC）有哪些？</h2><ul><li><strong>管道</strong>：包含匿名管道和有名管道。匿名管道仅用于父子进程和兄弟进程之间的通信，有名管道可以作为文件存在，可以让无亲缘关系的进程之间通信。特点是简单但单向，适合小数据流，效率较低。</li><li><strong>消息队列</strong>：内核维护的消息链表，进程通过唯一标识符访问。特点是支持不同类型消息（按优先级或类型读取），但涉及内核态切换，性能一般。</li><li><strong>共享内存</strong>：多个进程映射同一块物理内存，直接读写数据。特点是速度最快（无需复制数据），但需同步机制（如信号量）避免冲突。</li><li><strong>信号量</strong>：用于进程同步的计数器，通过 P()等待 和 V()释放操作控制资源访问。特点是解决竞态条件，本身不传递数据，需配合其他IPC使用。</li><li><strong>信号</strong>：异步通知机制（如 <code>SIGINT</code> 终止进程），通过 <code>kill</code> 命令或系统调用发送。特点是轻量级，仅传递信号编号，不能传输复杂数据。</li><li><strong>套间字</strong>：支持跨网络通信（如TCP&#x2F;UDP），也可用于本地进程。特点是通用性强，但开销较大，适用分布式系统。</li><li><strong>内存映射文件</strong>：文件映射到进程内存空间，多个进程共享同一文件。特点是适合大文件处理，类似共享内存但依赖文件系统。</li></ul><h3 id="选择依据"><a href="#选择依据" class="headerlink" title="选择依据"></a>选择依据</h3><ul><li><strong>速度</strong>：共享内存 &gt; 管道 &gt; 消息队列 &gt; 套接字。</li><li><strong>复杂度</strong>：套接字 &gt; 共享内存（需同步） &gt; 管道。</li><li><strong>场景</strong>：简单数据流用管道；高性能用共享内存；跨机器用套接字。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>两道常见的计算机网络面试题 4.9</title>
    <link href="/2025/04/09/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%204.9/"/>
    <url>/2025/04/09/%E4%B8%A4%E9%81%93%E5%B8%B8%E8%A7%81%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98%204.9/</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><p>HTTP是超文本传输协议，是互联网上应用最为广泛的一种网络通信协议，基于TCP或UDP（HTTP3），用来规范超文本（网络上的各种信息）的传输。默认端口号为80。</p><p>HTTPS是超文本传输安全协议，是HTTP的加强版，可以认为是在HTTP的基础上，额外使用 SSL&#x2F;TLS 协议用作加密和安全认证。默认端口号为443。</p><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol><li>HTTP的连接是简单无状态的，HTTPS的数据传输是经过证书加密的，安全性更高</li><li>HTTP是免费的，而HTTPS需要申请证书，这往往是收费的</li><li>HTTP默认是80端口，HTTPS默认是443端口。</li></ol><h3 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h3><ol><li>HTTPS的握手协议比较费时，从而影响了服务的响应速度以及吞吐量</li><li>HTTPS的证书体系并非完全安全</li><li>HTTPS在面对DDOS攻击时，无法起到防御作用</li><li>证书需要费钱，功能越强大的证书花费越高</li></ol><h2 id="访问网页的全过程"><a href="#访问网页的全过程" class="headerlink" title="访问网页的全过程"></a>访问网页的全过程</h2><ol><li><p>浏览器通过DNS协议，获取域名对应的IP地址</p><ul><li>DNS 是应用层协议，基于 UDP 协议之上，端口为 53 </li><li>IP 协议（网际协议）主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地</li><li>ARP 协议解决的是网络层地址（IP地址）和链路层地址（MAC地址）之间的转换问题。</li></ul></li><li><p>浏览器根据 IP 地址和端口号，向目标服务器发起一个 TCP&#x2F;UDP 连接请求</p><ul><li>TCP（传输控制协议 ）提供面向连接的，可靠的数据传输服务</li><li>UDP（用户数据协议）提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），简单高效</li></ul></li><li><p>浏览器在 TCP&#x2F;UDP 连接上，向服务器发送一个 HTTP 请求报文，请求获取网页的内容</p><ul><li>HTTP是超文本传输协议，是互联网上应用最为广泛的一种网络通信协议，基于TCP或UDP（HTTP3），用来规范超文本（网络上的各种信息）的传输。默认端口号为80</li></ul></li><li><p>TCP&#x2F;UDP 报文在网络层进行传输，被分组为IP数据包</p><ul><li><p>网络层的功能是转发和路由</p></li><li><p>转发：将分组从路由器的输入端口转移到合适的输出端口</p></li><li><p>路由：确定分组从源到目的经过的路径</p></li></ul></li><li><p>服务器收到 HTTP 请求报文后，处理请求，并返回 HTTP 响应报文给浏览器</p></li><li><p>浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示</p></li><li><p>浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中的悲观锁和乐观锁</title>
    <link href="/2025/04/08/Java%E4%B8%AD%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/"/>
    <url>/2025/04/08/Java%E4%B8%AD%E7%9A%84%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>悲观锁的代表是<code>syschronized</code>和<code>Lock</code>锁：</p><ol><li>其核心思想是：“线程只有占有了锁，才能去操作共享变量，每次只有一个线程站所成功，获取锁失败的线程，都得停下来等待”</li><li>线程从运行到阻塞，再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取<code>syschronized</code>和<code>Lock</code>锁时，如果锁已被占用，都会做几次重试操作，减少阻塞机会</li></ol><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>乐观锁的代表是<code>AtomicInteger</code>，使用cas来保证原子性：</p><ol><li>其核心思想是：“无需加锁，每次只有一个线程能成功修改共享变量，其他失败的线程不需要停止，不断重试直至成功”</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>需要多核cpu支持，且线程锁不应超过cpu核数</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC之volatite关键字</title>
    <link href="/2025/04/08/JUC%E4%B9%8Bvolatite%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2025/04/08/JUC%E4%B9%8Bvolatite%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>在之前对单例模式的介绍中，我提到了<code>volatite</code>，在那篇文章中，我们使用<code>volatite</code>是为了保证线程安全，那么<code>volatite</code>是否能够完全保证线程安全呢？</p><p>首先，线程安全需要考虑以下三个方面：</p><ol><li>可见性：一个线程对共享变量进行修改，另一个线程能看到最新结果</li><li>有序性：一个线程内代码按编写顺序执行</li><li>原子性：一个线程内多行代码以一个整体运行，期间不能有其他线程的代码插队</li></ol><p>直接说结论，<code>volatite</code>可以保证共享变量的可见性和有序性，但是不能保证原子性。</p><h2 id="为什么不能保证原子性？"><a href="#为什么不能保证原子性？" class="headerlink" title="为什么不能保证原子性？"></a>为什么不能保证原子性？</h2><p>举个例子，对<code>volatite</code>修饰的变量进行加或减操作时，会进行四步操作：</p><ol><li>取出该变量的值</li><li>取出要增加的数</li><li>把两者相加（减），从而得到和（差）</li><li>把和（差）赋值给该变量</li></ol><p>对变量用<code>volatite</code>修饰，并不能保证该变量在执行加或者减操作时，并不能保证四个步骤是一次性连着完成的。这就无法保证原子性了。</p><h2 id="volatite保证可见性的原理"><a href="#volatite保证可见性的原理" class="headerlink" title="volatite保证可见性的原理"></a>volatite保证可见性的原理</h2><p>当我们没有选择<code>-Xint</code>选项时，JIT可能会对我们的代码进行优化。如果JIT发现我们长时间特别多次地读取一个变量的值都一样，就会“帮助”我们优化这段代码，在这之后，我们对这个值进行修改的时候，我们的代码就不一定能见到值的修改，因为JIT以及优化了这段代码，这个变量在这段代码的机器码中可能已经是一个定值了。这就无法保证可见性了。</p><p>而选择<code>-Xint</code>，则是在告诉虚拟机，我只想用解释器，而不使用JIT优化，从而避免了这个问题。</p><p>但是选择<code>-Xint</code>有个很大的缺点是，这意味着整个代码都没有选用JIT优化，从而严重降低了代码的执行效率。</p><p>这个时候，使用<code>volatite</code>关键字修饰变量，就可以很好地解决这个问题：这意味着告诉虚拟机，针对这个变量，不进行JIT优化，这就保证了可见性，也保证了效率。</p><h2 id="volatite保证有序性的原理"><a href="#volatite保证有序性的原理" class="headerlink" title="volatite保证有序性的原理"></a>volatite保证有序性的原理</h2><p><code>volatite</code>是使用内存屏障保证有序性的。使用内存屏障后，我们可以保证对“写操作”，“对修饰的变量的写操作”一定晚于“原代码中早于‘对修饰的变量的写操作’的写操作”；对“读操作”，“对修饰变量的读操作”一定早于“源代码中晚于’对修饰变量的读操作‘的读操作”。看起来好像有点绕口，我们用代码举个例子：</p><p>假设我们对c变量用<code>volatite</code>关键字进行修饰，而a和b两个变量则没有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">1</span>;<br>b = <span class="hljs-number">2</span>;<br>c = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>不管<code>a = 1</code>和<code>b = 2</code>的执行顺序怎么样，<code>c = 3</code>一定在两者之后执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">d = c;<br>e = b;<br>f = a;<br></code></pre></td></tr></table></figure><p>不管<code>e = b</code>和<code>f = a</code>的执行顺序怎么样，<code>d = c</code>一定在两者之前执行。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC之Lock vs synchronized</title>
    <link href="/2025/03/30/synchronized/"/>
    <url>/2025/03/30/synchronized/</url>
    
    <content type="html"><![CDATA[<p>Lock和synchronized都能实现锁的功能，但是两者之间有着区别。</p><h2 id="语法层面"><a href="#语法层面" class="headerlink" title="语法层面"></a>语法层面</h2><ul><li><strong>synchronized是关键字</strong>，源码位于jvm，用cpp实现。</li><li><strong>Lock是接口</strong>，源码由jdk提供，用Java语言实现。</li><li><strong>使用synchronized时，退出同步代码块时，锁会自动释放；而使用Lock时，需要我们手动调用unlock方法释放锁。</strong></li></ul><h2 id="功能层面"><a href="#功能层面" class="headerlink" title="功能层面"></a>功能层面</h2><ul><li><strong>两者都是悲观锁，都具备基本的互斥、同步、锁重入功能。</strong></li><li><strong>Lock提供了许多synchronized所不具备的功能</strong>，比如获取等待状态、公平锁、可打断、可超时、多条件变量。<ul><li>Lock有相应的方法来获取那些线程被阻塞或等待。</li><li>Lock支持公平锁和非公平锁，synchronized只支持非公平锁。公平锁的意思是，争抢锁失败的线程在下次争抢锁时是按照先来先得的、不允许插队的，反之则为非公平锁。（但其实公平锁的吞吐量并不如非公平锁高）</li><li>这里可打断和可超时的意思是指，当一个线程想要获取一个锁的时候，如果锁已经被另一个线程占有了，如果我们使用的是synchronized，那么这个线程就只能一直等待同步代码块执行完毕，同步代码块中间不能被打断，等待锁的过程中没有超时时限；对于Lock锁，提供了对应的方法，比如一段时间没等到锁，就不要等下去了。</li><li>Lock还支持多组条件变量且可以有多个等待队列；而synchronized只能支持一组条件变量，只能有一个等待队列</li></ul></li><li><strong>Lock有适合不同场景的实现</strong>，比如ReentrantLock（可重入锁）、ReentrantTReadWriteLock（可重入读写锁，更适合读多写少的场景）。</li></ul><h2 id="性能层面"><a href="#性能层面" class="headerlink" title="性能层面"></a>性能层面</h2><ul><li><strong>在没有竞争或竞争很少的时候，synchronized</strong>做了很多优化，如偏向锁、轻量级锁等，<strong>性能不错</strong>。</li><li><strong>在竞争激烈的情况下，Lock的实现通常会提供更好的性能。</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC之sleep vs wait</title>
    <link href="/2025/03/30/wait/"/>
    <url>/2025/03/30/wait/</url>
    
    <content type="html"><![CDATA[<p>在<a href="https://flowertea.site/2025/03/29/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/">JUC之线程状态</a>这篇博客中，我提到了<strong>除了调用锁对象的wait(long)会让线程进入有时限等待外，还可以通过调用sleep(long)方法，来进入有时限等待状态。</strong>在这篇博客中，我就讲讲两者的对比。</p><h2 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h2><ul><li><strong>wait()、wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</strong>。</li><li>三者都可以被打断唤醒。</li></ul><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><h3 id="方法归属不同"><a href="#方法归属不同" class="headerlink" title="方法归属不同"></a>方法归属不同</h3><ul><li><strong>sleep(long)是Thread的静态方法。</strong></li><li><strong>wait()、wait(long)则是Object的成员方法</strong>，因此，每个对象都有这个方法。</li></ul><h3 id="醒来时机不同"><a href="#醒来时机不同" class="headerlink" title="醒来时机不同"></a>醒来时机不同</h3><p>三者除了都可以被打断唤醒外，醒来时机还有些不同：</p><ul><li><strong>执行wait(long)和sleep(long)的线程都会在等待相应时间（单位为毫秒）后醒来</strong>，而wait则不会。</li><li><strong>wait和wait(long)则还可以被notify唤醒</strong>，并且如果执行wait()的线程如果不被唤醒，就会一直等下去。</li></ul><h3 id="锁特性不同"><a href="#锁特性不同" class="headerlink" title="锁特性不同"></a>锁特性不同</h3><ul><li><strong>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</strong>（线程未必是持有锁才能运行）。</li><li><strong>wait方法执行后，会释放对象锁</strong>，允许其他线程获得该对象锁。（锁执行的wait，锁是自由的）。</li><li><strong>sleep方法</strong>如果在synchronized代码块中执行，则<strong>不会释放对象锁</strong>。（线程执行的sleep，带着锁睡觉）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC之线程池</title>
    <link href="/2025/03/29/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2025/03/29/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>线程池本质上就是管理一组线程，用来完成提交给线程池的任务。提交任务，可以调用线程池的submit方法，把实现了Runnable和Callable的任务对象，提交给线程池；而线程池就可以创建出线程对象来执行任务。</p><p>创建的线程分为两类：核心线程和救急线程。核心线程就是，当线程执行完任务之后，依然要保留到线程池中的线程；而救急线程，则是执行完任务之后，如果没有别的任务了，就不需要保留到线程池中的线程。两者的数目可以通过创建线程池的参数进行控制。当救急线程执行完任务，空闲下来的时候，它不会一直保留在池中，而是经过一段时间，即<code>keepAliveTime</code>，如果这段时间里，该线程没有接到其他任务，那么就会在经过这段时间后销毁。</p><p><code>workQueue</code>任务队列起到对任务的缓冲作用。当任务来临，线程池就会通过<code>threadFactory</code>线程工厂来创建核心线程执行任务；如果核心线程数已经达到<code>corePoolSize</code>，这时就会把任务放到<code>workQueue</code>中，等到核心线程完成了当前的任务，空闲下来了，就会对从<code>workQueue</code>中取出任务执行；如果把任务放到<code>workQueue</code>时，发现<code>workQueue</code>中的任务数量以达到其容量（一般，我们会对<code>workQueue</code>的容量设置一个可以达到的上限，从而避免内存紧张），那么这个时候就会生成救急线程来执行；当救急线程数量也达到最大的时候，即线程池中所有线程的数量达到了<code>maximumPoolSize</code>，就会根据<code>handler</code>拒绝策略进行处理。</p><h2 id="线程池的核心参数"><a href="#线程池的核心参数" class="headerlink" title="线程池的核心参数"></a>线程池的核心参数</h2><ol><li><code>corePoolSize </code>核心线程数目：最多保留的线程数</li><li><code>maximumPoolSize</code>最大线程数目：（核心线程数 + 救急线程数）的最大数目</li><li><code>keepAliveTime</code>生存时间：针对救急线程</li><li><code>unit</code>生存时间的单位：针对救急线程</li><li><code>workQueue</code>：阻塞队列</li><li><code>threadFactory</code>线程工厂：可以为线程创建时起个好名字</li><li><code>handler</code>拒绝策略：有4种</li></ol>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC之线程状态</title>
    <link href="/2025/03/29/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2025/03/29/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h2 id="线程有哪些状态（六种状态）"><a href="#线程有哪些状态（六种状态）" class="headerlink" title="线程有哪些状态（六种状态）"></a>线程有哪些状态（六种状态）</h2><p>Java中的线程分为6种状态，分别是<strong>NEW</strong>（新建）、<strong>RUNNABLE</strong>（可运行）、<strong>TERMINATED</strong>（终结）、<strong>BLOCKED</strong>（阻塞）、<strong>WAITING</strong>（等待）、<strong>TIMED_WAITING</strong>（有时限等待）。</p><p>当使用new关键字创建了一个线程对象之后，<strong>刚刚创建出来的线程对象，就处于新建状态</strong>。<strong>新建状态下的线程，仅仅是一个Java对象，没有和操作系统底层真正的线程关联起来</strong>，这时的线程不会被操作系统分配给CPU。<strong>当调用线程的start方法时，线程从NEW变为了RUNNABLE可运行状态，这时的线程才会与一个真正的线程关联起来。</strong></p><p>实际上，<strong>只有RUNNABLE状态下的线程，才有资格被分配给CPU执行代码</strong>。可运行状态下的线程会在分配给CPU后，执行代码，<strong>当代码执行完毕，线程便会进入TERMINATED终结状态，这个状态意味着线程的生命周期走到了尽头。底层所关联的真正的线程和相关资源也会得到释放</strong>。</p><p>从NEW到RUNNABLE再到TERMINATED，三个状态的转换只能是单项的。而<strong>RUNNABLE状态可以与BLOCKED、WAITING和TIMED_WAITING进行双向的转换，其过程也会复杂一些。</strong></p><p>线程在运行时，可能会出现<strong>多个线程争抢同一把锁</strong>，而锁是互斥的，所以最终只有一个线程会成功，其他线程都会失败，而这些<strong>失败的线程，就会由可运行状态转为阻塞状态。当持锁线程释放锁的时候，就会唤醒前边阻塞的线程</strong>，让他们去进行下一轮的竞争锁的动作，<strong>这一轮中，竞争锁成功的线程，就会由阻塞状态转变为可运行状态，如果失败了，则继续保持阻塞状态。</strong>这就是可运行和阻塞状态之间的转换。</p><p><strong>线程争抢锁成功后，要向下继续运行代码，结果发现还需要满足一些现在不满足的条件，这时候调用锁对象的wait()方法，持锁线程就会进入等待状态。</strong>拿到锁了，但是条件还不满足，不能老占着锁，必须把锁给出去，让别的线程去争抢锁，当条件满足后，再去重新获得这个锁。<strong>WAITING状态想要恢复成RUNNABLE状态，就要让另一个线程调用锁的notify()方法，把等待的线程唤醒，这时候，被唤醒的线程还需要重新争抢锁，成功了就会恢复成可运行线程。</strong></p><p>有时限等待的等待和等待的区别之一就是，切换状态调用的方法不一样。<strong>如果调用锁对象的wait(long)而不是wait()方法，那么线程就会进入有时限等待状态，除了通过notify()方法之外，有时限等待还可以通过等待时间结束，回到可运行状态。等待时间为wait(long)的参数，单位为毫秒。除了调用锁对象的wait(long)会让线程进入有时限等待外，还可以通过调用sleep(long)方法，来进入有时限等待状态。参数为等待时间，单位为毫秒，超时后就可以恢复为可运行状态。</strong></p><h2 id="线程有哪些状态（五种状态）"><a href="#线程有哪些状态（五种状态）" class="headerlink" title="线程有哪些状态（五种状态）"></a>线程有哪些状态（五种状态）</h2><p>线程的状态在Java层面是六种，但是在<strong>操作系统层面，则是五种：新建、就绪、运行、终结、阻塞</strong>。对比Java中线程的六种状态，RUNNABLE状态对应了就绪和运行，BLOCKED、WAITING、TIMED_WAITING三种状态，以及阻塞I&#x2F;O（Java中区分不了这种状态），共同对应了阻塞。</p><p>对于新建和终结，和Java中的NEW和TERMINATED较为相似，再次不多赘述。</p><p><strong>当线程可以分到CPU时间，并且正在执行，则为运行态；当线程有机会分到CPU时间，但是当前并未分配到CPU执行时间，则为就绪态；当线程不能分到CPU时间，则为阻塞态。</strong></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java单例模式</title>
    <link href="/2025/02/23/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/02/23/Java%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="方式一：饿汉式"><a href="#方式一：饿汉式" class="headerlink" title="方式一：饿汉式"></a>方式一：饿汉式</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>所谓饿汉式单例模式，就是<strong>在第一次获取单例对象之前（而不是获取时），就创建好了这个对象</strong>，比如下图的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singtelon1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singtelon1</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon1</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singtelon1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton1 is constructed&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton1 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将构造方法私有就是为了防止其他类调用，从而在一定程度上保证了单例。现在我们可以做一下测试，看下如果我尝试通过<code>getInstance</code>获取两次对象，对象是否是同一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon1.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon1.getInstance());<br>        System.out.println(Singtelon1.getInstance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行出的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看出，两次调用<code>getInstance</code>获取到的对象的哈希值是一致的，我们可以认为他们是同一个对象。这里的结果还说明了，对象是在类加载（第一次被使用）后就创建出的，因为<code>Singleton1 is constructed</code>在<code>Singleton1 is doing something</code>之前，而<code>Singleton1 is doing something</code>与获取对象和使用对象都没关系。</p><h3 id="破坏饿汉式单例模式的方法"><a href="#破坏饿汉式单例模式的方法" class="headerlink" title="破坏饿汉式单例模式的方法"></a>破坏饿汉式单例模式的方法</h3><h4 id="方法一：反射"><a href="#方法一：反射" class="headerlink" title="方法一：反射"></a>方法一：反射</h4><p>众所周知，我们<strong>可以通过反射获取构造方法，并给予可执行的权限，这样我们就可以在别的类中调用构造函数</strong>了！单例模式就这么被破坏掉了！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon1.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon1.getInstance());<br>        System.out.println(Singtelon1.getInstance());<br><br>        reflection(Singtelon1.class);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br>        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;反射创建对象：&quot;</span> + constructor.newInstance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Shell">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br>反射创建对象：Singtelon1@3d075dc0<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>从结果可以看出，我们的确构造了两个不同的<code>Singleton1</code>对象，这就破坏了单例模式。但是<strong>反射破坏的单例模式并非是无解的</strong>！我们可以这么修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singtelon1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singtelon1</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon1</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singtelon1</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)<br>            System.out.println(<span class="hljs-string">&quot;Singleton1 is constructed&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Singleton1 was constructed!!!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton1 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再来测试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br>Exception in thread &quot;main&quot; java.lang.reflect.InvocationTargetException<br>at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)<br>at java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:77)<br>at java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)<br>at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:499)<br>at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)<br>at Main.reflection(Main.java:17)<br>at Main.main(Main.java:11)<br>Caused by: java.lang.RuntimeException: Singleton1 was constructed!!!<br>at Singtelon1.&lt;init&gt;(Singtelon1.java:8)<br>... 7 more<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><p>可以看出，当我们尝试使用反射来构造<code>Singtelon1</code>的时候，代码是报错了的！这就解决了问题。</p><h4 id="方法二：反序列化"><a href="#方法二：反序列化" class="headerlink" title="方法二：反序列化"></a>方法二：反序列化</h4><p>如果<code>Singtelon1</code>实现了<code>Serializable</code>接口，那么这个<code>Singtelon1</code>就可以<strong>通过反序列化的方式得到一个新的对象，甚至不需要构造方法</strong>！反序列化有很多应用，在这里不进行说明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.Serializable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singtelon1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Singtelon1</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon1</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singtelon1</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton1 is constructed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon1 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton1 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon1.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon1.getInstance());<br>        System.out.println(Singtelon1.getInstance());<br><br>        serialization(Singtelon1.getInstance());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialization</span><span class="hljs-params">(Object instance)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(instance);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));<br>        System.out.println(<span class="hljs-string">&quot;反序列化创建对象：&quot;</span> +  ois.readObject());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br>反序列化创建对象：Singtelon1@2957fcb0<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>可以看出，反序列化不仅可以创建一个新的对象，而且还不需要调用构造方法！（因为我们得到了两个<code>Singleton1</code>对象，但是</p><p><code>Singleton1 is constructed</code>却只输出了一次）。幸运的是，这种<strong>破坏单例模式的方法也是可以解决的</strong>！</p><p>只需要我们在<code>Singleton1</code>类中增加一个<code>readResolve</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后问题就被解决了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br>反序列化创建对象：Singtelon1@3b07d329<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>原因是这样会使<code>ois.readObject()</code>执行的返回结果为INSTANCE</p><h4 id="方法三：unsafe"><a href="#方法三：unsafe" class="headerlink" title="方法三：unsafe"></a>方法三：unsafe</h4><p><strong>unsafe是jdk中内置的一个类，我们并不能直接访问，但我们可以利用反射来访问</strong>。而<strong>unsafe也可以通过不调用构造方法的方式得到对应类的对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon1.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon1.getInstance());<br>        System.out.println(Singtelon1.getInstance());<br><br>        unsafe(Singtelon1.class);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsafe</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> unsafe.allocateInstance(clazz);<br>        System.out.println(<span class="hljs-string">&quot;unsafe创建对象: &quot;</span> + instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton1 is constructed<br>Singleton1 is doing something<br>-------------------------------------------<br>Singtelon1@3b07d329<br>Singtelon1@3b07d329<br>unsafe创建对象: Singtelon1@3b9a45b3<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可惜的是，这种方法目前还没找到比较好的解决办法。</p><h2 id="方式二：枚举（饿汉式）"><a href="#方式二：枚举（饿汉式）" class="headerlink" title="方式二：枚举（饿汉式）"></a>方式二：枚举（饿汉式）</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>枚举类在编译后的字节码中，对每个选项都进行了饿汉式的创建，并在获取选项的时候是单例的，即不会再次创建。那么，假如我们的枚举类中只有一个选项，那么不就实现了单例模式吗？让我们看下下边的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单例集合</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Singtelon2</span> &#123;<br>    INSTANCE;<br><br>    Singtelon2()&#123; <span class="hljs-comment">// 枚举类的构造函数，默认是private的，所以可以去掉</span><br>        System.out.println(<span class="hljs-string">&quot;Singleton2 is constructed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123; <span class="hljs-comment">// 打印枚举类时，默认会打印类名，而没有hashCode，因此要重写toString</span><br>        <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon2 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton2 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Singtelon2.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon2.getInstance());<br>        System.out.println(Singtelon2.getInstance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton2 is constructed<br>Singleton2 is doing something<br>-------------------------------------------<br>Singtelon2@3b07d329<br>Singtelon2@3b07d329<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>显然，两次获取的对象是同一个，并且对象是在类加载（第一次被使用）后就创建出的，也就是用饿汉式创建出的。</p><h3 id="破坏枚举单例模式的方法"><a href="#破坏枚举单例模式的方法" class="headerlink" title="破坏枚举单例模式的方法"></a>破坏枚举单例模式的方法</h3><p>因为都是饿汉式的，所以破坏方式也和方式一中的一样：反射、反序列化、unsafe，是这样的吗？</p><h4 id="方法一：反射（不可行）"><a href="#方法一：反射（不可行）" class="headerlink" title="方法一：反射（不可行）"></a>方法一：反射（不可行）</h4><p>我们先仿照方式一中的代码试一试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Singtelon2.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon2.getInstance());<br>        System.out.println(Singtelon2.getInstance());<br><br>        reflection(Singtelon2.class);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br>        Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-literal">true</span>);<br>        System.out.println(<span class="hljs-string">&quot;反射创建对象：&quot;</span> + constructor.newInstance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton2 is constructed<br>Singleton2 is doing something<br>-------------------------------------------<br>Singtelon2@3b07d329<br>Singtelon2@3b07d329<br>Exception in thread &quot;main&quot; java.lang.NoSuchMethodException: Singtelon2.&lt;init&gt;()<br>at java.base/java.lang.Class.getConstructor0(Class.java:3585)<br>at java.base/java.lang.Class.getDeclaredConstructor(Class.java:2754)<br>at Main.reflection(Main.java:15)<br>at Main.main(Main.java:11)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><p>可以看到，代码报错了，这是因为我们在获取构造方法时除了问题。枚举类的构造方法，实际上是有两个参数的：枚举选项的名字（String类型）和选项的编号（int类型），所以我们修改代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reflection</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;<br>    Constructor&lt;?&gt; constructor = clazz.getDeclaredConstructor(String.class,<span class="hljs-type">int</span>.class);<br>    constructor.setAccessible(<span class="hljs-literal">true</span>);<br>    System.out.println(<span class="hljs-string">&quot;反射创建对象：&quot;</span> + constructor.newInstance(<span class="hljs-string">&quot;OTHER&quot;</span>,<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>然而结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton2 is constructed<br>Singleton2 is doing something<br>-------------------------------------------<br>Singtelon2@3b07d329<br>Singtelon2@3b07d329<br>Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Cannot reflectively create enum objects<br>at java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:492)<br>at java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:480)<br>at Main.reflection(Main.java:17)<br>at Main.main(Main.java:11)<br><br>Process finished with exit code 1<br></code></pre></td></tr></table></figure><p>可以看出，用反射来构造枚举类中的对象时，代码会报错，所以反射破坏不了枚举的单例模式。</p><h4 id="方法二：反序列化（不可行）"><a href="#方法二：反序列化（不可行）" class="headerlink" title="方法二：反序列化（不可行）"></a>方法二：反序列化（不可行）</h4><p>直接上测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon2.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon2.getInstance());<br>        System.out.println(Singtelon2.getInstance());<br><br>        serialization(Singtelon2.getInstance());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialization</span><span class="hljs-params">(Object instance)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(instance);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bos.toByteArray()));<br>        System.out.println(<span class="hljs-string">&quot;反序列化创建对象：&quot;</span> +  ois.readObject());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton2 is constructed<br>Singleton2 is doing something<br>-------------------------------------------<br>Singtelon2@3b07d329<br>Singtelon2@3b07d329<br>反序列化创建对象：Singtelon2@3b07d329<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看出，这里的反序列化没有破坏单例模式！！！</p><h4 id="方法三：unsafe-1"><a href="#方法三：unsafe-1" class="headerlink" title="方法三：unsafe"></a>方法三：unsafe</h4><p>测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> sun.misc.Unsafe;<br><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        Singtelon2.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon2.getInstance());<br>        System.out.println(Singtelon2.getInstance());<br><br>        unsafe(Singtelon2.class);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unsafe</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException, InstantiationException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) field.get(<span class="hljs-literal">null</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> unsafe.allocateInstance(clazz);<br>        System.out.println(<span class="hljs-string">&quot;unsafe创建对象: &quot;</span> + instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton2 is constructed<br>Singleton2 is doing something<br>-------------------------------------------<br>Singtelon2@3b07d329<br>Singtelon2@3b07d329<br>unsafe创建对象: Singtelon2@5f184fc6<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>同样的，这种方法不仅可以破坏单例，还没有找到解决办法。</p><h2 id="方式三：懒汉式"><a href="#方式三：懒汉式" class="headerlink" title="方式三：懒汉式"></a>方式三：懒汉式</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>饿汉式单例模式在类的在第一次获取单例对象之前（而不是获取时），就创建好了这个对象。而如果我们一直没有使用获取这个对象的方法，那就会造成内存的浪费，<strong>为了减少内存的浪费，我们可以采用懒汉式的单例模式，即当第一次获取单例对象时，才去创建对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singtelon3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singtelon3 INSTANCE;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singtelon3</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton is constructed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)<br>            INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon3</span>();<br>        <span class="hljs-keyword">return</span> INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton3 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>做一个测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Singtelon3.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;-------------------------------------------&quot;</span>);<br>        System.out.println(Singtelon3.getInstance());<br>        System.out.println(Singtelon3.getInstance());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton3 is doing something<br>-------------------------------------------<br>Singleton3 is constructed<br>Singtelon3@3b07d329<br>Singtelon3@3b07d329<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看出，这种方式的确可以保证单例（两次调用<code>getInstance</code>获取对象的哈希值一致），并且，类加载后并没有立即创建对象，而是在第一次获取对象的时候才对对象进行创建。这就是懒汉式的单例模式。</p><h3 id="懒汉式在多线程中的问题"><a href="#懒汉式在多线程中的问题" class="headerlink" title="懒汉式在多线程中的问题"></a>懒汉式在多线程中的问题</h3><p>但是，在多线程的环境中，这种模式就有很大的问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Singtelon3.getInstance());<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Singtelon3.getInstance());<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行上述代码，得到的结果是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton3 is constructed<br>Singtelon3@63236bfa<br>Singleton3 is constructed<br>Singtelon3@24224129<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看到，单例模式被破坏了！</p><p>原因可能有很多，总体来说就是下列代码中，两个线程都进入了if为true的代码中，然后各自创建了对象。而导致两个线程都进入了if为true的代码中的原因可能有很多，比如一个刚进去，就切换到另一个，这时还没创建好对象，判断结果还是true，另一个又进去了；或者是一个线程刚创建好对象，还没赋值给<code>INSTANCE</code>，就切换到另一个线程了，另一个线程判断结果还是true，然后又能执行<code>new Singtelon3()</code>操作了，等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)<br>        INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon3</span>();<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解决方法：双重检查锁"><a href="#解决方法：双重检查锁" class="headerlink" title="解决方法：双重检查锁"></a>解决方法：双重检查锁</h3><p>问题出在<code>两个线程都进入了if为true的代码中，然后各自创建了对象</code>，因此我们只要使得，两个线程里只能有一个线程创建对象就好了，因此就得到了如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon3 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">synchronized</span> (Singtelon3.class)&#123;<br>            <span class="hljs-keyword">if</span>(INSTANCE == <span class="hljs-literal">null</span>)<br>                INSTANCE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon3</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>当INSTANCE不为空：直接返回；当INSTANCE为空：先去尝试获得锁，在成功获得锁之前，可能已经有其他线程进入同步代码块创建对象了，因此进入同步代码块后，需要再次判断是否为空。</p><h3 id="为什么要加volatile"><a href="#为什么要加volatile" class="headerlink" title="为什么要加volatile"></a>为什么要加volatile</h3><p>但这里需要注意的是，这里的INSTANCE一定得是加了<code>volatile</code>关键字的原因如下：</p><ol><li><p>为了保证共享变量INSTANCE的可见性，在为INSTANCE赋值后能让其他线程立即看到。这个原因并不是主要原因，因为<code>INSTANCE == null</code>的判断会去获取INSTANCE的值，所以其实不加<code>volatile</code>并不会出现可见性的问题。（做测试发现确实没有出现问题）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton3 is constructed<br>Singtelon3@7a092293<br>Singtelon3@7a092293<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure></li><li><p><strong>为了保证编译代码的有序性</strong>。这是最核心的原因。如果不加<code>volatile</code>，则<code>INSTANCE = new Singtelon3();</code>的编译结果未必是我们想的那样。使用<code>javap -c -v -p Singtelon3.class</code>查看一下<code>Singtelon3.class</code>的反编译：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">17: new           #22                 // class Singtelon3    分配内存空间<br>20: dup<br>21: invokespecial #27                 // Method &quot;&lt;init&gt;&quot;:()V    对象内初始化赋值<br>24: putstatic     #21                 // Field INSTANCE:LSingtelon3;把对象赋值给INSTANCE<br></code></pre></td></tr></table></figure><p>可以看到以上三步，分别是分配空间，给对象初始化赋值，和把对象地址赋值给INSTANCE。<strong>分配空间肯定是第一步做的，但是后两步都是赋值，因此编译的代码可能会改变两者的顺序。</strong>这就有问题了：如果先执行了<code>putstatic</code> ，然后另一个线程就去进行<code>INSTANCE == null</code>的检测，发现不为null（因为已经赋值给INSTANCE了），但此时还没有对对象进行初始化，那么拿到的INSTANCE其实是有问题的，这就很危险了。所以，我们需要保证<code> invokespecial</code>一定在<code>putstatic</code>之前执行。而因为volatile有内存屏障，所以可以保证<code> invokespecial</code>一定在<code>putstatic</code>之前执行。这才是为什么我们要给INSTANCE加volatile。</p></li></ol><h2 id="方式四：内部类（懒汉式）"><a href="#方式四：内部类（懒汉式）" class="headerlink" title="方式四：内部类（懒汉式）"></a>方式四：内部类（懒汉式）</h2><p>我们知道，<code>private static final Singtelon1 INSTANCE = new Singtelon1();</code>这一步是线程安全的，这是因为这一步是在类的初始化时给静态变量赋值，是在静态代码块中执行的，而静态代码块会维护线程安全，因此只要我们也能通过静态代码块懒汉式地构建对象，那么不就不需要双重检查锁了吗？要实现这件事，就需要我们执行<code>private static final Singtelon1 INSTANCE = new Singtelon1()</code>，但我们又不希望在这之前执行类的方法时就对类初始化，所以我们可以通过内部类的方式来实现这一点。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singtelon4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singtelon4</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton4 is constructed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-type">Singtelon4</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singtelon4</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singtelon4 <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> Holder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Singleton4 is doing something&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只要我们不去使用<code>getInstance</code>方法，<code>Holder</code>就不会执行类初始化，也就不会创建<code>Singtelon4</code>对象，而其创建<code>Singtelon4</code>对象并复制的过程是在静态代码块中的，是线程安全的，因此我们轻松地实现了懒汉式单例模式。</p><p>测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Singtelon4.doSomething();<br>        System.out.println(<span class="hljs-string">&quot;----------------------------------&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Singtelon4.getInstance());<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Singtelon4.getInstance());<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Singleton4 is doing something<br>----------------------------------<br>Singleton4 is constructed<br>Singtelon4@5635b27f<br>Singtelon4@5635b27f<br><br>Process finished with exit code 0<br></code></pre></td></tr></table></figure><p>可以看出，当我执行<code>doSomething()</code>时，并不会引发单例对象的构建，而当我多线程地获取单例对象时，单例对象也只被创建了一次，也就是说，我们用这种方式，实现了懒汉式单例模式。</p><h2 id="单例模式在JDK中的体现"><a href="#单例模式在JDK中的体现" class="headerlink" title="单例模式在JDK中的体现"></a>单例模式在JDK中的体现</h2><p>项目中使用单例模式是危险的，因为可能会用错。但是有道这样的面试题：</p><blockquote><p>在哪里使用了单例模式 ？</p></blockquote><p>既然我们没能在项目使用单例模式，我们就不能举项目中的例子了。我们可以把目光投向JDK和框架上，在这里，我会介绍单例模式在JDK中的一些体现。</p><h3 id="例一：Runtime类"><a href="#例一：Runtime类" class="headerlink" title="例一：Runtime类"></a>例一：Runtime类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Runtime</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Runtime</span> <span class="hljs-variable">currentRuntime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runtime</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Version version;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &#123;<span class="hljs-doctag">@code</span> Runtime&#125; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &#123;<span class="hljs-doctag">@code</span> Runtime&#125; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title function_">getRuntime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Runtime</span><span class="hljs-params">()</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>不难看出，JDK里的Runtime类是用了单例模式的，而且是我们提到的饿汉式单例模式。</p><p>当我们要退出JVM时，会调用exit方法，这个方法是在System类中的，这个方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>       Runtime.getRuntime().exit(status);<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里是通过Runtime.getRuntime()获取到的Runtime单例对象。</p><p>除了exit之外，System类中还有很多别的方法也是通过Runtime.getRuntime()获取单例对象来调用Runtime类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> java.lang;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System</span> &#123;<br>    ......<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>        Runtime.getRuntime().exit(status);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">gc</span><span class="hljs-params">()</span> &#123;<br>        Runtime.getRuntime().gc();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runFinalization</span><span class="hljs-params">()</span> &#123;<br>        Runtime.getRuntime().runFinalization();<br>    &#125;<br>    <br>    <span class="hljs-meta">@CallerSensitive</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">load</span><span class="hljs-params">(String filename)</span> &#123;<br>        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);<br>    &#125;<br>    <br></code></pre></td></tr></table></figure><h3 id="例二：Console类"><a href="#例二：Console类" class="headerlink" title="例二：Console类"></a>例二：Console类</h3><p>刚刚提到了System类，这个类有个Console对象，也实现了单例模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Console cons;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the unique &#123;<span class="hljs-doctag">@link</span> java.io.Console Console&#125; object associated</span><br><span class="hljs-comment"> * with the current Java virtual machine, if any.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  The system console, if any, otherwise &#123;<span class="hljs-doctag">@code</span> null&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>   1.6</span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Console <span class="hljs-title function_">console</span><span class="hljs-params">()</span> &#123;<br>     Console c;<br>     <span class="hljs-keyword">if</span> ((c = cons) == <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-keyword">synchronized</span> (System.class) &#123;<br>             <span class="hljs-keyword">if</span> ((c = cons) == <span class="hljs-literal">null</span>) &#123;<br>                 cons = c = SharedSecrets.getJavaIOAccess().console();<br>             &#125;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> c;<br> &#125;<br></code></pre></td></tr></table></figure><p>这是我能找到的JDK中的唯一一个懒汉式单例模式了。</p><p>需要注意的是，这里的单例对象是Console的对象，但是是写在System中的，这也是为什么对cons的赋值并不是直接new，而是一定要用<code>SharedSecrets.getJavaIOAccess().console()</code>。</p><p>在Console类中，Console对象也是单例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Charset CHARSET;<br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">csname</span> <span class="hljs-operator">=</span> encoding();<br>    <span class="hljs-type">Charset</span> <span class="hljs-variable">cs</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (csname == <span class="hljs-literal">null</span>) &#123;<br>        csname = GetPropertyAction.privilegedGetProperty(<span class="hljs-string">&quot;sun.stdout.encoding&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (csname != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            cs = Charset.forName(csname);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123; &#125;<br>    &#125;<br>    CHARSET = cs == <span class="hljs-literal">null</span> ? Charset.defaultCharset() : cs;<br><br>    <span class="hljs-comment">// Set up JavaIOAccess in SharedSecrets</span><br>    SharedSecrets.setJavaIOAccess(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JavaIOAccess</span>() &#123;<br>        <span class="hljs-keyword">public</span> Console <span class="hljs-title function_">console</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (istty()) &#123;<br>                <span class="hljs-keyword">if</span> (cons == <span class="hljs-literal">null</span>)<br>                    cons = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Console</span>();<br>                <span class="hljs-keyword">return</span> cons;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Charset <span class="hljs-title function_">charset</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> CHARSET;<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Console cons;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">istty</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-title function_">Console</span><span class="hljs-params">()</span> &#123;<br></code></pre></td></tr></table></figure><h3 id="例三：Collections类"><a href="#例三：Collections类" class="headerlink" title="例三：Collections类"></a>例三：Collections类</h3><p>Conllections类是一个集合工具类，我们可以通过这个类来获取空的集合，这时的空集合就用到了单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyNavigableSet</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnmodifiableNavigableSet</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-meta">@java</span>.io.Serial<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">6291252904449939134L</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">EmptyNavigableSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-meta">@java</span>.io.Serial<br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span>        &#123; <span class="hljs-keyword">return</span> EMPTY_NAVIGABLE_SET; &#125;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&quot;rawtypes&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> NavigableSet&lt;?&gt; EMPTY_NAVIGABLE_SET =<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyNavigableSet</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>而且可以看到，为了保护类的单例，还实现了Serializable，从而避免了反序列化破坏单例。这种获取空集合的方式，在Conllections类中还有很多，在此不一一列举了。</p><p>除了直接把对象赋值给Conllections类的静态成员变量，Collections类内部还有很多内部类，这些内部类也运用了单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Iterator&lt;T&gt; <span class="hljs-title function_">emptyIterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (Iterator&lt;T&gt;) EmptyIterator.EMPTY_ITERATOR;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmptyIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EmptyIterator&lt;Object&gt; EMPTY_ITERATOR<br>        = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmptyIterator</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>(); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(); &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>        Objects.requireNonNull(action);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>顺藤摸瓜，我们还可以找到枚举饿汉式的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Comparator&lt;T&gt; <span class="hljs-title function_">reverseOrder</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) ReverseComparator.REVERSE_ORDER;<br>   &#125;<br></code></pre></td></tr></table></figure><p>Conllections类中的reverseOrder()方法，返回值是ReverseComparator类的REVERSE_ORDER，这是一个单例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReverseComparator</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Comparable&lt;Object&gt;&gt;, Serializable &#123;<br><br>    <span class="hljs-meta">@java</span>.io.Serial<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7207038068494060240L</span>;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReverseComparator</span> <span class="hljs-variable">REVERSE_ORDER</span><br>        <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReverseComparator</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> &#123;<br>        <span class="hljs-keyword">return</span> c2.compareTo(c1);<br>    &#125;<br><br>    <span class="hljs-meta">@java</span>.io.Serial<br>    <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> Collections.reverseOrder(); &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Comparator.naturalOrder();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而Comparator的naturalOrder方法的返回值，也是单例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> T&gt;&gt; Comparator&lt;T&gt; <span class="hljs-title function_">naturalOrder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (Comparator&lt;T&gt;) Comparators.NaturalOrderComparator.INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparators</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Comparators</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;no instances&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Compares &#123;<span class="hljs-doctag">@link</span> Comparable&#125; objects in natural order.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> Comparable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">NaturalOrderComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Comparable&lt;Object&gt;&gt; &#123;<br>        INSTANCE;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Comparable&lt;Object&gt; c1, Comparable&lt;Object&gt; c2)</span> &#123;<br>            <span class="hljs-keyword">return</span> c1.compareTo(c2);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Comparator&lt;Comparable&lt;Object&gt;&gt; <span class="hljs-title function_">reversed</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> Comparator.reverseOrder();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里的INSTANCE是枚举类NaturalOrderComparator的唯一一个选项，这就是通过枚举实现饿汉式单例模式的体现。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git基础教程</title>
    <link href="/2025/01/31/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
    <url>/2025/01/31/Git%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="为什么要学习Git"><a href="#为什么要学习Git" class="headerlink" title="为什么要学习Git"></a>为什么要学习Git</h2><p>在软件工程中，需要对整个团队的代码和文档（项目成果）进行统一的管理，这就需要软件配置管理了。软件配置管理（SCM）是指通过执行版本控制、变更控制的规程，以及使用合适的配置管理软件，来保证所有配置项的完整性和可跟踪性。配置管理是对工作成果的一种有效保护。而Git就是一种软件配置管理软件。</p><p>相比于别的软件配置管理软件（如VSS、CVS、Subversion等），Git作为开源的分布式版本控制系统，可以更加有效、高速地处理从很小到很大的项目版本控制。所以，我们需要学习Git。</p><h2 id="一些基础概念"><a href="#一些基础概念" class="headerlink" title="一些基础概念"></a>一些基础概念</h2><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本：说到版本，大家都不太陌生。我们常说的有软件版本和文件版本。对于软件版本，我们常用的软件都有其版本，比如JDK有1.8、11、17等版本，Mysql有5.7、8.0等版本；而文件版本则是用于保存重要的历史记录，且可以用来恢复数据而产生的，比如你对某个文件建立了一个副本，然后去修改原文件，这种情况下，两个文件的文件版本就是不同的。</p><p>由此可见，对文件版本的控制是重要的，而手动进行每一个文件的版本控制是费时费力的，所以我们需要版本控制软件来帮助我们自动对版本进行控制。</p><p>版本控制软件的基础功能有：</p><ol><li>保存和管理软件</li><li>提供客户端工具进行访问</li><li>提供不同版本文件的比对功能</li></ol><h3 id="集中式版本控制"><a href="#集中式版本控制" class="headerlink" title="集中式版本控制"></a>集中式版本控制</h3><p>要对版本进行控制，最容易想到的办法就是有一个集中管理软件版本的中央服务器，然后每个开发者都从这个服务器获取最新代码并对其进行更新。</p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E9%9B%86%E4%B8%AD%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png?raw=true" alt="集中式版本控制"></p><p>这么做虽然可以实现多人协作开发中对版本的控制，但是存在着一些问题：</p><ol><li>文件冲突问题：如果几个开发者都先下载了同一版本的文件，并分别对其进行修改，那么最终，服务器最新版本的文件只能是最后一名上传者所修改的文件，而之前的上传者上传的文件都会被覆盖掉。对于不同的集中式版本控制软件，解决方法不完全相同，比如对文件进行加锁等，但这样显然会降低开发效率。不过可以使用版本控制软件的不同版本文件比对功能，来比对修改的内容，并对每个开发者的修改进行合并，但这难免遇到冲突问题。</li><li>单点故障问题：如果中央服务器寄了，或者网络不通了，这样对文件的下载和上传就无法进行！开发流程就会被卡住，这很影响开发效率，并且此时还有文件丢失无法找回的风险！</li></ol><p>为了解决单点冲突问题，可以使用分布式版本控制。</p><h3 id="分布式版本控制"><a href="#分布式版本控制" class="headerlink" title="分布式版本控制"></a>分布式版本控制</h3><p>如果每个开发者在本地都将中央服务器的资源下载了一份，这样，当中央服务器寄了，或者网络不通了，开发者照样可以通过本地的资源进行文件的下载和上传。当中央服务器和网络恢复后，再将对本地资源库的修改上传到中央服务器即可。</p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.png?raw=true" alt="分布式版本控制"></p><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>想要安装Git，可以访问Git官方网站：<a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git">Git - 安装 Git (git-scm.com)</a></p><p>这个网站中也对Git有充分的介绍，可以作为本教程的进阶使用。</p><p>同时，我们也可以安装Github Desktop：<a href="https://github.com/apps/desktop">GitHub Desktop | Simple collaboration from your desktop</a></p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E5%AE%89%E8%A3%85GithubDesktop.png?raw=true" alt="安装GithubDesktop"></p><p>关于Github Desktop的使用，在这里不多赘述，作为一个Git的图形化界面，Github Desktop的使用是较为简单的，很快就能上手。</p><h2 id="Git基础操作"><a href="#Git基础操作" class="headerlink" title="Git基础操作"></a>Git基础操作</h2><p>我们可以用Git来<strong>创建仓库</strong>。当我们创建好一个仓库，会发现指定的文件夹（工作区）中有一个.git文件夹（可能会被隐藏），这里的.git文件夹就相当于当前的本地仓库，而我们在工作区中进行文件操作，会通过与.git文件夹进行比对，从而实现不同版本文件的比对功能。</p><p>假如我们在工作区文件夹中创建一个a.txt文件，我们的本地仓库其实是没有这个文件的，想要让本地仓库有这个文件，就需要<strong>提交（commit）</strong>来把文件上传到本地仓库。</p><p>本地仓库中会记录不同版本的文件，每个版本的文件都会有对应的版本号，当我们commit之后，我们看到的文件就是本地仓库中最新版本的文件。要区分不同文件版本，就需要<strong>版本号</strong>，版本号是由40个16进制的数字（0到f）组成的，因为产生于提交时，所以又叫提交码。版本号不仅可以指明文件的版本，还可以用来查询提交信息、定位文件在仓库中的位置。</p><p>假设现在有多个开发者来共同开发一个软件，但是他们开发的是不同的模块。由于开发过程中需要多次提交，而每个人的提交顺序又是不固定的，所以这时我们的提交就没有什么规律可言，当我们想要定位到某一次提交的具体内容，就很难找到了，另外，多个开发者可能会修改同一份文件，这就会导致文件的冲突，从而带来风险。同时，频繁的提交还会导致仓库越来越大，这样就会降低不同版本文件比对的效率。</p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E5%88%86%E6%94%AF%E5%89%8D.png?raw=true" alt="分支前"></p><p>要解决以上的三个问题，我们可以借助Git的<strong>分支（branch）</strong>功能。每个分支都是当前版本库的副本，每个开发者都在这个副本上进行操作，最后再把不同的副本进行<strong>合并（merge）</strong>即可。当我们在user分支创建、修改、删除文件并commit后，order分支的仓库是看不到的，想要让order的库中也有操作过的文件，就需要进行合并。</p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E5%88%86%E6%94%AF%E5%90%8E.png?raw=true" alt="分支后"></p><p>当我们对同一份文件进行合并，其内容可能是有冲突的，这种时候，Git会给出区别，并让你自己选择最终内容从而解决冲突，然后就可以继续合并了。</p><p>可以通过.git文件夹中的HEAD，查看保存当前最新版本号的文件的位置，同时该文件名即当前的分支名。</p><p>在提交时，需要开发者给出提交的描述信息，而在合并时，会Git自动给出描述信息，如果我们想自己添加描述信息，则可以使用<strong>标签（tag）</strong>。</p><p>上边的操作是针对本地仓库的，而在实际开发中，我们会使用远程仓库，毕竟Git是一个分布式版本控制软件，是需要有一个中央服务器来保存资源的。可是我们自己搭建远程仓库，成本还是较大的，所以我们可以选择第三方的代码托管平台，比如Github、Gitee等，它们可以为我们提供远程仓库服务。当我们创建好远程仓库之后，我们可以使用<strong>clone</strong>操作来获取远程仓库的内容。当我们commit后，我们修改后的文件就会到达本地仓库，但还没有到达远程仓库，想要上传到远程仓库需要进行<strong>push</strong>操作，来把本地库的内容推到远程库。</p><p><strong>README文件</strong>可以作为仓库资源信息的介绍，因此在我们对项目进行修改的过程中，README文件也要进行对应的修改。</p><p>可以使用**.gitignore文件**来让Git忽略掉指定文件的修改。</p><h2 id="Git常用指令"><a href="#Git常用指令" class="headerlink" title="Git常用指令"></a>Git常用指令</h2><p>Git有很多常用的指令，下图是一张对Git常用指令的概括图。</p><p><img src="https://github.com/JLQusername/JLQusername.github.io/blob/main/img/%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4.png?raw=true" alt="常见指令"></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><h4 id="查看Git版本"><a href="#查看Git版本" class="headerlink" title="查看Git版本"></a>查看Git版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git -v<br></code></pre></td></tr></table></figure><h4 id="配置Git的用户名称和邮箱"><a href="#配置Git的用户名称和邮箱" class="headerlink" title="配置Git的用户名称和邮箱"></a>配置Git的用户名称和邮箱</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name &lt;用户名称&gt;<br>git config user.email &lt;用户邮箱&gt;<br></code></pre></td></tr></table></figure><p>我们还可以通过修改.git文件夹里的config文件来完成修改配置。并且可以在命令中添加 <code>  --global</code>来进行全局操作，然后会发现我们的用户目录下会有一个.gitconfig文件，可以通过修改这个文件来完成全局配置。在Github Desktop中，也可以在图形化界面设置当前操作的用户名称和用户邮箱。</p><h3 id="仓库指令"><a href="#仓库指令" class="headerlink" title="仓库指令"></a>仓库指令</h3><h4 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br></code></pre></td></tr></table></figure><p>执行完这个指令后，文件夹中就会有.git文件夹。</p><p>用Github Desktop和用命令直接创建的仓库有一些区别，比如用Github Desktop创建的仓库中，初始会有.gitattributes文件。并且用命令行创建仓库在初始化完成而没有其他操作的时候，HEAD文件会表明当前在master分支，且我们去HEAD文件中给出的路径去寻找版本号，会发现没有此文件，这是因为我们还没有进行过提交。而用Github Desktop创建的仓库中，一开始便会有一次提交（提交了.gitattributes文件），所以一开始就有版本号，并且我们可以自己在客户端中选择分支名（master、main或者其他）。</p><h4 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;远程仓库路径&gt; &lt;本地名称&gt;<br></code></pre></td></tr></table></figure><p>当我们克隆远程仓库之后，我们本地会有远程仓库的所有信息，包括之前的提交记录等。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><h4 id="添加文件到暂存区"><a href="#添加文件到暂存区" class="headerlink" title="添加文件到暂存区"></a>添加文件到暂存区</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add &lt;file&gt;        <span class="hljs-comment"># 添加指定文件，可以使用通配符，比如git add *.txt就是添加所有以.txt结尾的文件</span><br>git add .             <span class="hljs-comment"># 添加所有修改</span><br>git add &lt;directory&gt;/  <span class="hljs-comment"># 添加某个目录下的所有修改</span><br>git add -p   <span class="hljs-comment"># 交互模式（逐个选择修改片段）</span><br></code></pre></td></tr></table></figure><ul><li><code>-u</code> 或 <code>--update</code>：仅添加已跟踪（已纳入版本控制）的文件的修改（不包含新增文件）</li><li><code>-A</code> 或 <code>--all</code>：添加所有修改（包括未跟踪的新文件）</li><li><code>-i</code> 或 <code>--interactive</code>：进入交互式暂存模式（细分修改块）</li></ul><h4 id="从版本控制中移除文件"><a href="#从版本控制中移除文件" class="headerlink" title="从版本控制中移除文件"></a>从版本控制中移除文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">rm</span> &lt;file&gt;  <span class="hljs-comment"># 删除文件（同时从工作区和暂存区移除）</span><br>git <span class="hljs-built_in">rm</span> --cached &lt;file&gt;  <span class="hljs-comment"># 仅从暂存区删除，保留工作区文件（文件变为未跟踪状态）</span><br></code></pre></td></tr></table></figure><p>如果文件已被修改但未提交，直接使用 <code>git rm</code> 会失败（需先提交或强制删除）。若文件已手动删除，直接运行 <code>git add &lt;file&gt;</code> 或 <code>git rm &lt;file&gt;</code> 效果相同。</p><h4 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;提交说明&quot;</span><br>git commit  <span class="hljs-comment"># 自动打开编辑器编写提交信息（支持多行说明）</span><br></code></pre></td></tr></table></figure><ul><li><code>-a</code> 或 <code>--all</code>：自动暂存所有已跟踪文件的修改（跳过 <code>git add</code>）。</li><li><code>--amend</code>：修正上一次提交（修改提交信息或追加文件）。</li><li><code>--no-edit</code>：与 <code>--amend</code> 配合使用，保留原提交信息。</li></ul><h4 id="恢复误删除的文件"><a href="#恢复误删除的文件" class="headerlink" title="恢复误删除的文件"></a>恢复误删除的文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git restore &lt;file&gt;<br></code></pre></td></tr></table></figure><p>当我们不小心删除了某个文件，我们可以从最新提交中恢复它。但如果最新提交中没有这个文件，我们就无法恢复它。但是我们过去提交过这个文件，所以我们可以通过reset来把版本库重置到有这个文件的那一次提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset &lt;目标提交版本号前七位&gt;<br></code></pre></td></tr></table></figure><ul><li><code>--soft</code> ：HEAD指针回退到目标提交，并且暂存区和工作区保留修改，修改处于已暂存状态。</li><li><code>--mixed</code>：HEAD指针回退到目标提交，暂存区被重置，工作区保留修改，也就是说需要重新add，这也是默认的reset模式。</li><li><code>--hard </code>：HEAD指针回退到目标提交，但是暂存区和工作区完全重置，会丢弃所有修改，需要慎用！</li></ul><p>如果我们不想失去之前的提交记录，那么就不应该用reset，而是用revert。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git revert &lt;目标提交版本号前七位&gt; <br></code></pre></td></tr></table></figure><p>这么做会回退到目标版本号之前的一个版本，并且往提交历史中新增一条revert的记录，而不是直接丢掉之前的记录。</p><h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><ul><li>Changes to be committed：已暂存但未提交的文件（绿色）。</li><li>Changes not staged for commit：已修改但未暂存的文件（红色）。</li><li>Untracked files：未被 Git 跟踪的新文件（红色）。</li></ul><h4 id="查看文件差异"><a href="#查看文件差异" class="headerlink" title="查看文件差异"></a>查看文件差异</h4><table><thead><tr><th><strong>场景</strong></th><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>工作区 vs 暂存区</td><td><code>git diff</code></td><td>默认行为，查看未暂存的修改（工作区与暂存区的差异）</td></tr><tr><td>暂存区 vs 最新提交</td><td><code>git diff --staged</code>（或 <code>--cached</code>）</td><td>查看已暂存但未提交的修改</td></tr><tr><td>比较两次提交之间的差异</td><td><code>git diff &lt;commit1&gt; &lt;commit2&gt;</code></td><td>对比两个提交的差异</td></tr><tr><td>比较不同分支的差异</td><td><code>git diff &lt;branch1&gt;..&lt;branch2&gt;</code></td><td>显示两个分支最新提交的差异</td></tr><tr><td>查看某次提交的修改内容</td><td><code>git diff &lt;commit&gt;^!</code></td><td><code>^!</code> 表示对比该提交与其父提交的差异</td></tr></tbody></table><table><thead><tr><th><strong>选项</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>--color-words</code></td><td>高亮显示单词级差异（而非行级）</td></tr><tr><td><code>--stat</code></td><td>仅显示修改统计（文件列表和增删行数）</td></tr><tr><td><code>-w</code></td><td>忽略空格变化（适合格式化调整的场景）</td></tr><tr><td><code>-- &lt;file&gt;</code></td><td>仅比较指定文件（如 <code>git diff HEAD -- README.md</code>）</td></tr></tbody></table><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch &lt;分支名&gt;<br></code></pre></td></tr></table></figure><p>你可以通过这个命令来创建一个分支，但是在创建分支前，需要提交一次，也就是说，你不可以刚init完，什么都没提交，就创建分支（分支是基于提交的）。</p><h4 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch <span class="hljs-comment"># 查看本地分支，当前分支会以 * 标记</span><br></code></pre></td></tr></table></figure><ul><li><code>-a</code>：查看包括远程分支在内的所有分支</li><li><code>-v</code>：查看各个分支的最后一次提交信息</li></ul><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout &lt;分支名&gt;<span class="hljs-comment"># 切换到指定分支</span><br>git checkout -b &lt;分支名&gt; <span class="hljs-comment"># 创建并切换到指定分支</span><br></code></pre></td></tr></table></figure><p>也可以使用switch，Git 2.23+的版本可用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch &lt;分支名&gt;<span class="hljs-comment"># 切换到指定分支</span><br>git switch -c &lt;分支名&gt; <span class="hljs-comment"># 创建并切换到指定分支</span><br></code></pre></td></tr></table></figure><h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -d &lt;分支名&gt;<span class="hljs-comment"># 删除本地分支</span><br>git branch -D &lt;分支名&gt; <span class="hljs-comment"># 若分支未合并，则需要用-D进行强制删除</span><br>git push origin --delete &lt;分支名&gt;<span class="hljs-comment"># 删除远程分支</span><br></code></pre></td></tr></table></figure><h4 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch -m &lt;新分支名&gt;<span class="hljs-comment"># 重命名当前分支</span><br>git branch -m &lt;旧分支名&gt; &lt;新分支名&gt;<span class="hljs-comment"># 重命名指定分支</span><br></code></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge &lt;分支名&gt;<span class="hljs-comment"># 把指定分支合并到当前分支</span><br></code></pre></td></tr></table></figure><p>当合并分支发生冲突时，分支会进入MERGING，我们需要手动解决冲突，然后进行提交，这样就可以完成merge。</p><h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p>直接操作版本号会有一些不方便，为了解决这个问题，我们可以使用标签tag</p><h4 id="查看标签"><a href="#查看标签" class="headerlink" title="查看标签"></a>查看标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag<span class="hljs-comment"># 查看所有标签</span><br></code></pre></td></tr></table></figure><h4 id="设置标签"><a href="#设置标签" class="headerlink" title="设置标签"></a>设置标签</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag&lt;标签内容&gt; &lt;版本号&gt;<span class="hljs-comment"># 为指定版本号设置标签</span><br></code></pre></td></tr></table></figure><p>用Github Desktop也可以设置标签</p><h3 id="日志操作"><a href="#日志操作" class="headerlink" title="日志操作"></a>日志操作</h3><table><thead><tr><th><strong>场景</strong></th><th><strong>命令</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>查看完整提交日志</td><td><code>git log</code></td><td>默认按时间倒序显示所有提交</td></tr><tr><td>简洁单行显示</td><td><code>git log --oneline</code></td><td>每个提交显示为一行</td></tr><tr><td>图形化分支日志</td><td><code>git log --graph --oneline</code></td><td>用 ASCII 图形展示分支合并日志</td></tr><tr><td>按时间过滤提交</td><td><code>git log --since=&quot;yyyy-mm-dd&quot; --until=&quot;yyyy-mm-dd&quot;</code></td><td>显示指定时间范围内的提交</td></tr><tr><td>按作者过滤提交</td><td><code>git log --author=&quot;作者名&quot;</code></td><td>显示特定作者的提交</td></tr><tr><td>按关键词搜索提交信息</td><td><code>git log --grep=&quot;关键词&quot;</code></td><td>查找提交信息中包含关键词的提交</td></tr><tr><td>查看某文件的修改日志</td><td><code>git log -- &lt;file&gt;</code></td><td>显示影响指定文件的所有提交</td></tr><tr><td>用自定义输出格式查看</td><td><code>git log --pretty=format:&quot;格式&quot;</code></td><td>按照输入的格式查看提交日志</td></tr><tr><td>查看某一版本的提交历史</td><td><code>git log &lt;版本号&gt;</code></td><td>查看指定版本号及其之前的提交</td></tr></tbody></table><h3 id="远程仓库指令"><a href="#远程仓库指令" class="headerlink" title="远程仓库指令"></a>远程仓库指令</h3><p>当我们查看config文件，可以看到remote的信息，remote右边的就是远程仓库的名称，它可以在操作中代替下方的url。</p><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add &lt;远程仓库名&gt; &lt;远程仓库路径（url）&gt;<br></code></pre></td></tr></table></figure><h4 id="删除远程仓库"><a href="#删除远程仓库" class="headerlink" title="删除远程仓库"></a>删除远程仓库</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git remote <span class="hljs-built_in">remove</span> &lt;远程仓库名&gt;<br></code></pre></td></tr></table></figure><h4 id="重命名远程仓库"><a href="#重命名远程仓库" class="headerlink" title="重命名远程仓库"></a>重命名远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote rename &lt;旧名&gt; &lt;新名&gt;<br></code></pre></td></tr></table></figure><h4 id="把本地仓库的内容推送到远程仓库"><a href="#把本地仓库的内容推送到远程仓库" class="headerlink" title="把本地仓库的内容推送到远程仓库"></a>把本地仓库的内容推送到远程仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push &lt;远程仓库名&gt;<br></code></pre></td></tr></table></figure><h4 id="从远程仓库拉取最新版本"><a href="#从远程仓库拉取最新版本" class="headerlink" title="从远程仓库拉取最新版本"></a>从远程仓库拉取最新版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull &lt;远程仓库名&gt;<br></code></pre></td></tr></table></figure><h3 id="查看Git对象信息"><a href="#查看Git对象信息" class="headerlink" title="查看Git对象信息"></a>查看Git对象信息</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cat-file &lt;类型或选项&gt; &lt;版本号&gt;<br></code></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td><code>-t</code></td><td>查看对象的类型（如 <code>blob</code>、<code>tree</code>、<code>commit</code>、<code>tag</code>）</td></tr><tr><td><code>-s</code></td><td>查看对象的大小（字节数）</td></tr><tr><td><code>-p</code></td><td>以友好格式打印对象内容（最常用）</td></tr><tr><td><code>-e</code></td><td>仅检查对象是否存在（静默模式，无输出）</td></tr></tbody></table><p>可以通过此命令来查看Git对象信息，比如提交、树、标签、文件内容等。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>参与项目汇总</title>
    <link href="/2025/01/28/%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/28/%E5%8F%82%E4%B8%8E%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><h3 id="程序设计范式课程项目"><a href="#程序设计范式课程项目" class="headerlink" title="程序设计范式课程项目"></a>程序设计范式课程项目</h3><p>项目简介：程序设计范式的期末项目，用C++和UE5而制作的原创游戏Mana-Tower，十分有趣。</p><p>项目链接：<a href="https://github.com/IcySugar000/Mana-Tower">IcySugar000&#x2F;Mana-Tower: Mana Tower, Mana Power! (github.com)</a></p><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="专业实习（恒生电子训练营）课程项目"><a href="#专业实习（恒生电子训练营）课程项目" class="headerlink" title="专业实习（恒生电子训练营）课程项目"></a>专业实习（恒生电子训练营）课程项目</h3><p>项目简介：恒生电子训练营的项目，后端使用Spring Boot和Mybatis，但可惜前端未能完成。</p><p>项目链接：<a href="https://gitee.com/AngelaGYY/tlfs">TLFS: TongLi Financial System (gitee.com)</a></p><h3 id="软件工程课程设计项目"><a href="#软件工程课程设计项目" class="headerlink" title="软件工程课程设计项目"></a>软件工程课程设计项目</h3><p>项目简介：软件工程的课程设计项目，运用了在恒生电子训练营学到的基金业务知识，并使用了微服务架构。后端使用Spring Cloud、Mybatis Plus等，前端使用Vue3，是一个较为完善的项目，但是也有着较强的可扩展新。</p><p>项目链接：<a href="https://github.com/JLQusername/fund-trading-system">JLQusername&#x2F;fund-trading-system: 同济大学软件工程大三课程项目，基于微服务架构的基金销售系统 (github.com)</a></p><h3 id="文件管理工具项目"><a href="#文件管理工具项目" class="headerlink" title="文件管理工具项目"></a>文件管理工具项目</h3><p>项目简介：在大三上学期的课余时间，想要练习一下Java中的文件IO相关内容，因此做了这个项目，主要起到练习作用。</p><p>项目链接：<a href="https://github.com/JLQusername/FileManagementTool">JLQusername&#x2F;FileManagementTool (github.com)</a></p><h2 id="C-1"><a href="#C-1" class="headerlink" title="C#"></a>C#</h2><h3 id="数据库课程设计"><a href="#数据库课程设计" class="headerlink" title="数据库课程设计"></a>数据库课程设计</h3><p>项目简介：数据库课程设计项目，后端被要求使用C#，数据库被要求使用Oracle，前端选用了Vue3框架，虽然较为完善，但是后端代码可以改进的地方很多，整个项目的业务逻辑也过于简单。</p><p>项目链接：<a href="https://github.com/Haookok/FlowersWhispering">Haookok&#x2F;FlowersWhispering: Database course design for the second semester of the sophomore year in 2024, School of Software, Tongji University (github.com)</a></p><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>项目简介：在大三上学期的课余时间，想要练习一下前端，因此做了这个项目，使用了Nuxt3、UnoCss、MongoDB等，主要起到练习作用。</p><p>项目链接：<a href="https://github.com/JLQusername/WriteAPersonalBlog">JLQusername&#x2F;WriteAPersonalBlog (github.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>参与项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目经历</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell基础编程学习</title>
    <link href="/2024/12/16/Shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/12/16/Shell%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a>Shell 变量</h2><p>定义变量时，变量名不加美元符号，<strong>变量名和等号之间不能有空格</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;b907&quot;<br></code></pre></td></tr></table></figure><p>变量名的命名须遵循如下规则：</p><ul><li>只包含数字、字母和下划线</li><li>不能以数字开头</li><li>避免使用Shell关键字</li><li>使用大写字母表示常量</li><li>避免使用空格</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">FLOWER=&quot;www.flowertea.site&quot;<br>LD_LIBRARY_PATH=&quot;/bin/&quot;<br>_var=&quot;123&quot;<br>var2=&quot;abc&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">错误示例：</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">避免使用<span class="hljs-keyword">if</span>作为变量名</span><br>if=&quot;some_value&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">避免使用 $ 等特殊符号</span><br><span class="hljs-meta prompt_">variable_with_$</span><span class="language-bash">=42</span><br>?var=123<br>user*name=bbb<br><span class="hljs-meta prompt_"># </span><span class="language-bash">避免空格</span><br>variable with space=&quot;value&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">有可能会导致错误</span><br>variable_name = value<br></code></pre></td></tr></table></figure><p>除了显式地直接赋值，还可以用语句给变量赋值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">for file in `ls /etc`<br>或<br>for file in $(ls /etc)<br></code></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;b907&quot;<br>echo $your_name<br>echo $&#123;your_name&#125;<br></code></pre></td></tr></table></figure><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，<strong>推荐给所有变量加上花括号</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">for skill in Ada Coffe Action Java; do<br>    echo &quot;I am good at $&#123;skill&#125;Script&quot;<br>done<br></code></pre></td></tr></table></figure><p>如果不给skill变量加花括号，写成<code>echo &quot;I am good at $skillScript&quot;</code>，解释器就会把<code>$skillScript</code>当成一个变量（其值为空）</p><p>已定义的变量，可以被重新定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;b907&quot;<br>echo $your_name<br>your_name=&quot;flowertea&quot;<br>echo $your_name<br></code></pre></td></tr></table></figure><p>第二次赋值的时候不能写<code>$your_name=&quot;flowertea&quot;</code>，使用变量的时候才加美元符（$）</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用 <code>readonly </code>命令可以将变量定义为只读变量，只读变量的值不能被改变</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>myUrl=&quot;https://www.google.com&quot;<br>readonly myUrl<br>myUrl=&quot;https://www.flowertea.site&quot;<br></code></pre></td></tr></table></figure><p>运行脚本，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">/bin/sh: NAME: This variable is read only.<br></code></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用 <code>unset</code> 命令可以删除变量，变量被删除后不能再次使用，<code>unset </code>命令不能删除只读变量</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>一些主要的类型包括：</p><h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><p>在 Shell中，变量通常被视为字符串，最常用最有用的数据类型，可以使用单引号 <strong>‘</strong> 或双引号 <strong>“</strong> 来定义字符串</p><p>字符串可以用单引号，也可以用双引号，也可以不用引号</p><h5 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">str=&#x27;this is a string&#x27;<br></code></pre></td></tr></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的（字符串拼接除外）</li><li>单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用</li></ul><h5 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;b907&quot;<br>str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;<br>echo -e $str<br></code></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hello, I know you are &quot;b907&quot;! <br></code></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul><h5 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;flower&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用双引号拼接</span><br>greeting=&quot;hello, &quot;$your_name&quot; !&quot;<br>greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;<br>echo $greeting  $greeting_1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用单引号拼接</span><br>greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;<br>greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;<br>echo $greeting_2  $greeting_3<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">hello, flower ! hello, flower !<br>hello, flower ! hello, $&#123;your_name&#125; !<br></code></pre></td></tr></table></figure><h5 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;abcd&quot;<br>echo $&#123;#string&#125;   # 输出 4<br></code></pre></td></tr></table></figure><p>变量为字符串时，<code>$&#123;#string&#125;</code> 等价于 <code>$&#123;#string[0]&#125;</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;abcd&quot;<br>echo $&#123;#string[0]&#125;   # 输出 4<br></code></pre></td></tr></table></figure><h5 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h5><p>从字符串第 2 个字符开始截取 4 个字符：（第一个字符的索引值为0）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">string=&quot;flower is a great site&quot;<br>echo $&#123;string:1:4&#125; # 输出 lowe<br></code></pre></td></tr></table></figure><h5 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h5><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Shell">string=&quot;flower is a great site&quot;<br>echo `expr index &quot;$string&quot; io`  # 输出 3<br></code></pre></td></tr></table></figure><h4 id="整数变量"><a href="#整数变量" class="headerlink" title="整数变量"></a>整数变量</h4><p>在一些Shell中，可以使用 <code>declare</code> 或 <code>typeset</code> 命令来声明整数变量，这样的变量只包含整数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">declare -i my_integer=42<br></code></pre></td></tr></table></figure><p>这样的声明告诉 Shell 将 my_integer 视为整数，如果尝试将非整数值赋给它，Shell会尝试将其转换为整数</p><h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>Shell 也支持数组，允许在一个变量中存储多个值，bash支持一维数组（不支持多维数组），并且没有限定数组的大小</p><p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0</p><p>数组可以是整数索引数组或关联数组，以下是一个简单的整数索引数组的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">my_array=(1 2 3 4 5)<br></code></pre></td></tr></table></figure><p>或者关联数组：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Shell">declare -A associative_array<br>associative_array[&quot;name&quot;]=&quot;B907&quot;<br>associative_array[&quot;age&quot;]=30<br></code></pre></td></tr></table></figure><h5 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h5><p>在 Shell 中，用括号来表示数组，数组元素用”空格”符号分割开。定义数组的一般形式为：<code>array_name=(value0 value1 value2 value3)</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">array_name=(value0 value1 value2 value3)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>array_name=(<br>value0<br>value1<br>value2<br>value3<br>)<br></code></pre></td></tr></table></figure><p>还可以单独定义数组的各个分量：（可以不使用连续的下标，而且下标的范围没有限制）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">array_name[0]=value0<br>array_name[1]=value1<br>array_name[n]=valuen<br></code></pre></td></tr></table></figure><h5 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h5><p>Bash 支持关联数组，可以使用任意的字符串、或者整数作为下标来访问数组元素，关联数组使用 <code>declare</code>命令来声明，语法格式为<code>declare -A array_name</code>,<code>-A</code> 选项就是用于声明一个关联数组，关联数组的键是唯一的</p><p>创建一个关联数组 <strong>site</strong>，并创建不同的键值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">declare -A site=([&quot;google&quot;]=&quot;www.google.com&quot; [&quot;flowertea&quot;]=&quot;www.flowertea.site&quot; [&quot;taobao&quot;]=&quot;www.taobao.com&quot;)<br></code></pre></td></tr></table></figure><p>也可以先声明一个关联数组，然后再设置键和值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">declare -A site<br>site[&quot;google&quot;]=&quot;www.google.com&quot;<br>site[&quot;flowertea&quot;]=&quot;www.flowertea.site&quot;<br>site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;<br></code></pre></td></tr></table></figure><p>访问关联数组元素可以使用指定的键，格式为<code>array_name[&quot;index&quot;]</code></p><h5 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h5><p>读取数组元素值的一般格式是：<code>$&#123;数组名[下标]&#125;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">valuen=$&#123;array_name[n]&#125;<br></code></pre></td></tr></table></figure><p>使用 @ 或 * 可以获取数组中的所有元素，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>my_array[0]=A<br>my_array[1]=B<br>my_array[2]=C<br>my_array[3]=D<br><br>echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;<br>echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x test.sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test.sh</span><br>数组的元素为: A B C D<br>数组的元素为: A B C D<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">declare -A site<br>site[&quot;google&quot;]=&quot;www.google.com&quot;<br>site[&quot;flowertea&quot;]=&quot;www.flowertea.site&quot;<br>site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;<br><br>echo &quot;数组的元素为: $&#123;site[*]&#125;&quot;<br>echo &quot;数组的元素为: $&#123;site[@]&#125;&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x test.sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test.sh</span><br>数组的元素为: www.google.com www.flowertea.site www.taobao.com<br>数组的元素为: www.google.com www.flowertea.site www.taobao.com<br></code></pre></td></tr></table></figure><p>在数组前加一个感叹号 ! 可以获取数组的所有键</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">declare -A site<br>site[&quot;google&quot;]=&quot;www.google.com&quot;<br>site[&quot;flowertea&quot;]=&quot;www.flowertea.site&quot;<br>site[&quot;taobao&quot;]=&quot;www.taobao.com&quot;<br><br>echo &quot;数组的键为: $&#123;!site[*]&#125;&quot;<br>echo &quot;数组的键为: $&#123;!site[@]&#125;&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">数组的键为: google flowertea taobao<br>数组的键为: google flowertea taobao<br></code></pre></td></tr></table></figure><h5 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h5><p>方法与获取字符串长度的方法相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">取得数组元素的个数</span><br>length=$&#123;#array_name[@]&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br>length=$&#123;#array_name[*]&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">取得数组单个元素的长度</span><br>length=$&#123;#array_name[n]&#125;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境，如 PATH 变量包含了操作系统搜索可执行文件的路径：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Shell">echo $PATH<br></code></pre></td></tr></table></figure><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>有一些特殊变量在 Shell 中具有特殊含义，例如 <code>$0</code> 表示脚本的名称，<code>$1</code>, <code>$2</code>, 等表示脚本的参数，<code>$#</code>表示传递给脚本的参数数量，<code>$?</code> 表示上一个命令的退出状态等</p><h3 id="Shell-注释"><a href="#Shell-注释" class="headerlink" title="Shell 注释"></a>Shell 注释</h3><p>以 # 开头的行就是注释，会被解释器忽略，通过每一行加一个 # 号设置多行注释</p><p>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果</p><p>多行注释还可以使用以下格式（使用 Here 文档）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>注释内容...<br>注释内容...<br>注释内容...<br>EOF<br></code></pre></td></tr></table></figure><p>以上例子中，: 是一个空命令，用于执行后面的 Here 文档，<code>&lt;&lt;&#39;EOF&#39; </code>表示开启 Here 文档，<code>COMMENT</code> 是 Here 文档的标识符，在这两个标识符之间的内容都会被视为注释，不会被执行</p><p>EOF 也可以使用其他符号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">: &lt;&lt;&#x27;COMMENT&#x27;<br>这是注释的部分。<br>可以有多行内容。<br>COMMENT<br><br>:&lt;&lt;&#x27;<br>注释内容...<br>注释内容...<br>注释内容...<br>&#x27;<br><br>:&lt;&lt;!<br>注释内容...<br>注释内容...<br>注释内容...<br>!<br></code></pre></td></tr></table></figure><p>我们也可以使用了冒号 <strong>:</strong> 命令，并用单引号 <strong>‘</strong> 将多行内容括起来</p><p>由于冒号是一个空命令，这些内容不会被执行，格式为：<code>: + 空格 + 单引号</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">: &#x27;<br>这是注释的部分。<br>可以有多行内容。<br>&#x27;<br></code></pre></td></tr></table></figure><h2 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a>Shell 传递参数</h2><p>可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为 <code>$n</code>，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。</p><p>例如可以使用 <code>$1、$2</code> 等来引用传递给脚本的参数，其中 <code>$1</code> 表示第一个参数，<code>$2</code> 表示第二个参数，依此类推（<code>$&#123;11&#125;</code> 表示第一个参数）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;Shell 传递参数实例！&quot;;<br>echo &quot;执行的文件名：$0&quot;;<br>echo &quot;第一个参数为：$1&quot;;<br>echo &quot;第二个参数为：$2&quot;;<br>echo &quot;第三个参数为：$3&quot;;<br></code></pre></td></tr></table></figure><p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x test.sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test.sh 1 2 3</span><br>Shell 传递参数实例！<br>执行的文件名：./test.sh<br>第一个参数为：1<br>第二个参数为：2<br>第三个参数为：3<br></code></pre></td></tr></table></figure><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th align="left">参数处理</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$#</td><td align="left">传递到脚本的参数个数</td></tr><tr><td align="left">$*</td><td align="left">以一个单字符串显示所有向脚本传递的参数。如<code>$*</code>加上双引号，以<code>&quot;$1 $2 … $n&quot;</code>（字符串）的形式输出所有参数</td></tr><tr><td align="left">$$</td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$@</td><td align="left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。如<code>$@</code>加上双引号，以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> （数组）的形式输出所有参数</td></tr><tr><td align="left">$-</td><td align="left">显示Shell使用的当前选项，与<code>set</code>命令功能相同</td></tr><tr><td align="left">$?</td><td align="left">显示最后命令的退出状态，0表示没有错误，其他任何值表明有错误</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;Shell 传递参数实例！&quot;;<br>echo &quot;第一个参数为：$1&quot;;<br><br>echo &quot;参数个数为：$#&quot;;<br>echo &quot;传递的参数作为一个字符串显示：$*&quot;;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x test.sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test.sh 1 2 3</span><br>Shell 传递参数实例！<br>第一个参数为：1<br>参数个数为：3<br>传递的参数作为一个字符串显示：1 2 3<br></code></pre></td></tr></table></figure><p>$* 与 $@ 区别：</p><ul><li>相同点：都是引用所有参数</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，则 “$*” 等价于 “1 2 3”（传递了一个参数），而 “$@” 等价于 “1” “2” “3”（传递了三个参数）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>echo &quot;-- \$* 演示 ---&quot;<br>for i in &quot;$*&quot;; do<br>    echo $i<br>done<br><br>echo &quot;-- \$@ 演示 ---&quot;<br>for i in &quot;$@&quot;; do<br>    echo $i<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> +x test.sh</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./test.sh 1 2 3</span><br>-- $* 演示 ---<br>1 2 3<br>-- $@ 演示 ---<br>1<br>2<br>3<br></code></pre></td></tr></table></figure><h2 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a>Shell 基本运算符</h2><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><p>原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 <code>awk</code> 和 <code>expr</code>，<code>expr</code> 最常用</p><p><code>expr</code> 是一款表达式计算工具，使用它能完成表达式的求值操作，例如，两个数相加(注意使用的是反引号，而不是单引号 )：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>val=`expr 2 + 2`<br>echo &quot;两数之和为 : $val&quot;<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样</li><li>完整的表达式要被反引号包含，这个字符不是常用的单引号，在 <code>Esc 键</code>下边</li></ul><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">+</td><td align="left">加法</td><td align="left"><code>expr $a + $b</code> 结果为 30</td></tr><tr><td align="left">-</td><td align="left">减法</td><td align="left"><code>expr $a - $b</code> 结果为 -10</td></tr><tr><td align="left">*</td><td align="left">乘法</td><td align="left"><code>expr $a \* $b</code> 结果为  200</td></tr><tr><td align="left">&#x2F;</td><td align="left">除法</td><td align="left"><code>expr $b / $a</code> 结果为 2</td></tr><tr><td align="left">%</td><td align="left">取余</td><td align="left"><code>expr $b % $a</code> 结果为 0</td></tr><tr><td align="left">&#x3D;</td><td align="left">赋值</td><td align="left"><code>a=$b</code> 把变量 b 的值赋给 a</td></tr><tr><td align="left">&#x3D;&#x3D;</td><td align="left">相等，用于比较两个数字，相同则返回 true</td><td align="left"><code>[ $a == $b ]</code> 返回 false</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不相等，用于比较两个数字，不相同则返回 true</td><td align="left"><code>[ $a != $b ]</code> 返回 true</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li><p>条件表达式要放在方括号之间，并且要有空格，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></p></li><li><p>乘号<code>*</code>前边必须加反斜杠<code>\</code>才能实现乘法运算</p></li><li><p><code>if...then...fi</code> 是条件语句</p></li><li><p>在 MAC 中 shell 的 <code>expr</code> 语法是：<code>$((表达式))</code>，此处表达式中的<code>*</code>不需要转义符号 <code>\</code></p></li></ul><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left"><code>-eq</code></td><td align="left">检测两个数是否相等，相等返回 true</td><td align="left"><code>[ $a -eq $b ] </code>返回 false</td></tr><tr><td align="left"><code>-ne</code></td><td align="left">检测两个数是否不相等，不相等返回 true</td><td align="left"><code>[ $a -ne $b ] </code>返回 true</td></tr><tr><td align="left"><code>-gt</code></td><td align="left">检测左边的数是否大于右边的，如果是，则返回 true</td><td align="left"><code>[ $a -gt $b ] </code>返回 false</td></tr><tr><td align="left"><code>-lt</code></td><td align="left">检测左边的数是否小于右边的，如果是，则返回 true</td><td align="left"><code>[ $a -lt $b ]</code> 返回 true</td></tr><tr><td align="left"><code>-ge</code></td><td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true</td><td align="left"><code>[ $a -ge $b ]</code> 返回 false</td></tr><tr><td align="left"><code>-le</code></td><td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true</td><td align="left"><code>[ $a -le $b ]</code> 返回 true</td></tr></tbody></table><h3 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h3><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">!</td><td align="left">非运算，表达式为 true 则返回 false，否则返回 true</td><td align="left"><code>[ ! false ] </code>返回 true</td></tr><tr><td align="left">-o</td><td align="left">或运算，有一个表达式为 true 则返回 true</td><td align="left"><code>[ $a -lt 20 -o $b -gt 100 ] </code>返回 true</td></tr><tr><td align="left">-a</td><td align="left">与运算，两个表达式都为 true 才返回 true</td><td align="left"><code>[ $a -lt 20 -a $b -gt 100 ]</code>返回 false</td></tr></tbody></table><p><strong>注意：实际使用<code>!</code>时，遇到了一些问题，使用时需要多加小心</strong></p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left"><code>&amp;&amp;</code></td><td align="left">逻辑的 AND</td><td align="left"><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] </code>返回 false</td></tr><tr><td align="left">&#96;</td><td align="left"></td><td align="left">&#96;</td></tr></tbody></table><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><p>下表列出了常用的字符串运算符，假定变量 a 为 <code>&quot;abc&quot;</code>，变量 b 为 <code>&quot;efg&quot;</code>：</p><table><thead><tr><th align="left">运算符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">检测两个字符串是否相等，相等返回 true</td><td align="left">[ $a &#x3D; $b ] 返回 false</td></tr><tr><td align="left">!&#x3D;</td><td align="left">检测两个字符串是否不相等，不相等返回 true</td><td align="left">[ $a !&#x3D; $b ] 返回 true</td></tr><tr><td align="left">-z</td><td align="left">检测字符串长度是否为0，为0返回 true</td><td align="left">[ -z $a ] 返回 false</td></tr><tr><td align="left">-n</td><td align="left">检测字符串长度是否不为 0，不为 0 返回 true</td><td align="left">[ -n “$a” ] 返回 true</td></tr><tr><td align="left">$</td><td align="left">检测字符串是否不为空，不为空返回 true</td><td align="left">[ $a ] 返回 true</td></tr></tbody></table><h3 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h3><p>文件测试运算符用于检测 Unix 文件的各种属性，属性检测描述如下：</p><table><thead><tr><th align="left">操作符</th><th align="left">说明</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left">-b file</td><td align="left">检测文件是否是块设备文件，如果是，则返回 true</td><td align="left">[ -b $file ] 返回 false</td></tr><tr><td align="left">-c file</td><td align="left">检测文件是否是字符设备文件，如果是，则返回 true</td><td align="left">[ -c $file ] 返回 false</td></tr><tr><td align="left">-d file</td><td align="left">检测文件是否是目录，如果是，则返回 true</td><td align="left">[ -d $file ] 返回 false</td></tr><tr><td align="left">-f file</td><td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true</td><td align="left">[ -f $file ] 返回 true</td></tr><tr><td align="left">-g file</td><td align="left">检测文件是否设置了 <code>SGID 位</code>，如果是，则返回 true</td><td align="left">[ -g $file ] 返回 false</td></tr><tr><td align="left">-k file</td><td align="left">检测文件是否设置了<code>粘着位(Sticky Bit)</code>，如果是，则返回 true</td><td align="left">[ -k $file ] 返回 false</td></tr><tr><td align="left">-p file</td><td align="left">检测文件是否是有名管道，如果是，则返回 true</td><td align="left">[ -p $file ] 返回 false</td></tr><tr><td align="left">-u file</td><td align="left">检测文件是否设置了 <code>SUID 位</code>，如果是，则返回 true</td><td align="left">[ -u $file ] 返回 false</td></tr><tr><td align="left">-r file</td><td align="left">检测文件是否可读，如果是，则返回 true</td><td align="left">[ -r $file ] 返回 true</td></tr><tr><td align="left">-w file</td><td align="left">检测文件是否可写，如果是，则返回 true</td><td align="left">[ -w $file ] 返回 true</td></tr><tr><td align="left">-x file</td><td align="left">检测文件是否可执行，如果是，则返回 true</td><td align="left">[ -x $file ] 返回 true</td></tr><tr><td align="left">-s file</td><td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true</td><td align="left">[ -s $file ] 返回 true</td></tr><tr><td align="left">-e file</td><td align="left">检测文件（包括目录）是否存在，如果是，则返回 true</td><td align="left">[ -e $file ] 返回 true</td></tr></tbody></table><p>其他检查符：</p><ul><li><code>-S</code>: 判断某文件是否 socket</li><li><code>-L</code>: 检测文件是否存在并且是一个符号链接</li></ul><h3 id="自增和自减操作符"><a href="#自增和自减操作符" class="headerlink" title="自增和自减操作符"></a>自增和自减操作符</h3><p>尽管 Shell 本身没有像 C、C++ 或 Java 那样的 ++ 和 – 操作符，但可以通过其他方式实现相同的功能，以下是一些常见的方法：</p><p><code>let 命令</code>允许对整数进行算术运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化变量</span><br>num=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自增</span><br>let num++<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自减</span><br>let num--<br>echo $num<br></code></pre></td></tr></table></figure><p><code>$(( )) 语法</code> 也是进行算术运算的一种方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化变量</span><br>num=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自增</span><br>num=$((num + 1)) # num=$[num + 1]<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自减</span><br>num=$((num - 1)) # num=$[num - 1]<br>echo $num<br></code></pre></td></tr></table></figure><p><code>expr</code> 命令可以用于算术运算，但在现代脚本中不如 <code>let</code> 和 <code>$(( ))</code> 常用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化变量</span><br>num=5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自增</span><br>num=$(expr $num + 1) # num=`expr $num + 1`<br><span class="hljs-meta prompt_"># </span><span class="language-bash">自减</span><br>num=$(expr $num - 1) # num=`expr $num - 1`<br>echo $num<br></code></pre></td></tr></table></figure><h2 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a>Shell echo命令</h2><p>Shell 的 echo 指令用于字符串的输出，命令格式：<code>echo string</code>，可以使用echo实现更复杂的输出格式控制</p><h3 id="显示普通字符串"><a href="#显示普通字符串" class="headerlink" title="显示普通字符串"></a>显示普通字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;It is a test&quot;<br></code></pre></td></tr></table></figure><p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo It is a test<br></code></pre></td></tr></table></figure><h3 id="显示转义字符"><a href="#显示转义字符" class="headerlink" title="显示转义字符"></a>显示转义字符</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;\&quot;It is a test\&quot;&quot;<br></code></pre></td></tr></table></figure><p>结果为<code>&quot;It is a test&quot;</code>，同样，双引号也可以省略</p><h3 id="显示变量"><a href="#显示变量" class="headerlink" title="显示变量"></a>显示变量</h3><p><code>read 命令</code>从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/sh</span><br>read name <br>echo &quot;$name It is a test&quot;<br></code></pre></td></tr></table></figure><p>以上代码保存为 test.sh，name 接收标准输入的变量，结果将是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@www ~]# sh test.sh<br>OK                     #标准输入<br>OK It is a test        #输出<br></code></pre></td></tr></table></figure><h3 id="显示换行"><a href="#显示换行" class="headerlink" title="显示换行"></a>显示换行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;OK! \n&quot; # -e 开启转义<br>echo &quot;It is a test&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">OK!<br><br>It is a test<br></code></pre></td></tr></table></figure><h3 id="显示不换行"><a href="#显示不换行" class="headerlink" title="显示不换行"></a>显示不换行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行<br>echo &quot;It is a test&quot;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">OK! It is a test<br></code></pre></td></tr></table></figure><h3 id="显示结果定向至文件"><a href="#显示结果定向至文件" class="headerlink" title="显示结果定向至文件"></a>显示结果定向至文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &quot;It is a test&quot; &gt; myfile<br></code></pre></td></tr></table></figure><h3 id="原样输出字符串，不进行转义或取变量-用单引号"><a href="#原样输出字符串，不进行转义或取变量-用单引号" class="headerlink" title="原样输出字符串，不进行转义或取变量(用单引号)"></a>原样输出字符串，不进行转义或取变量(用单引号)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;$name\&quot;&#x27;<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">name\&quot;</span><br></code></pre></td></tr></table></figure><h3 id="显示命令结果"><a href="#显示命令结果" class="headerlink" title="显示命令结果"></a>显示命令结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo `date`<br></code></pre></td></tr></table></figure><p>结果将显示当前日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Mon Dec 16 15:45:30 UTC 2024<br></code></pre></td></tr></table></figure><h2 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a>Shell printf 命令</h2><p>Shell 的另一个输出命令 <code>printf</code>：<code>printf 命令</code>模仿 C 程序库（library）里的 <code>printf() 程序</code></p><p><code>printf</code> 由 POSIX 标准所定义，因此使用 <code>printf</code> 的脚本比使用 <code>echo</code> 移植性好</p><p><code>printf </code>使用引用文本或空格分隔的参数，外面可以在 <code>printf</code> 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等</p><p>默认的 <code>printf </code>不会像 <code>echo</code> 自动添加换行符，我们可以手动添加 <code>\n</code>，<code>printf 命令</code>的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf  format-string  [arguments...]<br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li><code>format-string</code> :一个格式字符串，它包含普通文本和格式说明符</li><li><code>arguments</code>: 用于填充格式说明符的参数列表</li></ul><p>格式说明符由 <code>% 字符</code>开始，后跟一个或多个字符，用于指定输出的格式，常用的格式说明符包括：</p><ul><li><code>%s</code>：字符串</li><li><code>%d</code>：十进制整数</li><li><code>%f</code>：浮点数</li><li><code>%c</code>：字符</li><li><code>%x</code>：十六进制数</li><li><code>%o</code>：八进制数</li><li><code>%b</code>：二进制数</li><li><code>%e</code>：科学计数法表示的浮点数</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  <br>printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 <br>printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 <br>printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">姓名     性别   体重kg<br>郭靖     男      66.12<br>杨过     男      48.65<br>郭芙     女      47.99<br></code></pre></td></tr></table></figure><p><code>%s %c %d %f</code> 都是格式替代符，<code>％s</code> 输出一个字符串，<code>％d</code> 整型输出，<code>％c</code> 输出一个字符，<code>％f</code> 输出实数，以小数形式输出</p><p><code>%-10s</code> 指一个宽度为 10 个字符（<code>-</code> 表示左对齐，没有则表示右对齐），任何字符都会被显示在 10 个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来（）</p><p><code>%-4.2f</code> 指格式化为小数，其中 <code>.2</code> 指保留 2 位小数</p><p><code>printf</code> 的转义序列：</p><table><thead><tr><th align="left">序列</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\a</td><td align="left">警告字符，通常为ASCII的BEL字符</td></tr><tr><td align="left">\b</td><td align="left">后退</td></tr><tr><td align="left">\c</td><td align="left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td align="left">\f</td><td align="left">换页（<code>formfeed</code>）</td></tr><tr><td align="left">\n</td><td align="left">换行</td></tr><tr><td align="left">\r</td><td align="left">回车（<code>Carriage return</code>）</td></tr><tr><td align="left">\t</td><td align="left">水平制表符</td></tr><tr><td align="left">\v</td><td align="left">垂直制表符</td></tr><tr><td align="left">\</td><td align="left">一个字面上的反斜杠字符</td></tr><tr><td align="left"><code>\ddd</code></td><td align="left">表示1到3位数八进制值的字符，仅在格式字符串中有效</td></tr><tr><td align="left"><code>\0ddd</code></td><td align="left">表示1到3位的八进制值字符</td></tr></tbody></table><h2 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a>Shell test 命令</h2><p>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试</p><h3 id="数值测试"><a href="#数值测试" class="headerlink" title="数值测试"></a>数值测试</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>-eq</code></td><td align="left">等于则为真</td></tr><tr><td align="left"><code>-ne</code></td><td align="left">不等于则为真</td></tr><tr><td align="left"><code>-gt</code></td><td align="left">大于则为真</td></tr><tr><td align="left"><code>-ge</code></td><td align="left">大于等于则为真</td></tr><tr><td align="left"><code>-lt</code></td><td align="left">小于则为真</td></tr><tr><td align="left"><code>-le</code></td><td align="left">小于等于则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">num1=100<br>num2=100<br>if test $[num1] -eq $[num2] # if test $num1 -eq $num2 也可以<br>then<br>    echo &#x27;两个数相等！&#x27;<br>else<br>    echo &#x27;两个数不相等！&#x27;<br>fi<br></code></pre></td></tr></table></figure><p>代码中的 <code>[]</code> 执行基本的算数运算</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=5<br>b=6<br><br>result=$[a+b] # 这种写法不可以乘法，四则运算符两边可以有空格，可以把a换乘$a（b也一样）<br>echo &quot;result 为： $result&quot;<br></code></pre></td></tr></table></figure><h3 id="字符串测试"><a href="#字符串测试" class="headerlink" title="字符串测试"></a>字符串测试</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">&#x3D;</td><td align="left">等于则为真</td></tr><tr><td align="left">!&#x3D;</td><td align="left">不相等则为真</td></tr><tr><td align="left">-z 字符串</td><td align="left">字符串的长度为零则为真</td></tr><tr><td align="left">-n 字符串</td><td align="left">字符串的长度不为零则为真</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">num1=&quot;b907&quot;<br>num2=&quot;b908&quot;<br>if test $num1 = $num2<br>then<br>    echo &#x27;两个字符串相等!&#x27;<br>else<br>    echo &#x27;两个字符串不相等!&#x27;<br>fi<br></code></pre></td></tr></table></figure><h3 id="文件测试"><a href="#文件测试" class="headerlink" title="文件测试"></a>文件测试</h3><table><thead><tr><th align="left">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">-e 文件名</td><td align="left">如果文件存在则为真</td></tr><tr><td align="left">-r 文件名</td><td align="left">如果文件存在且可读则为真</td></tr><tr><td align="left">-w 文件名</td><td align="left">如果文件存在且可写则为真</td></tr><tr><td align="left">-x 文件名</td><td align="left">如果文件存在且可执行则为真</td></tr><tr><td align="left">-s 文件名</td><td align="left">如果文件存在且至少有一个字符则为真</td></tr><tr><td align="left">-d 文件名</td><td align="left">如果文件存在且为目录则为真</td></tr><tr><td align="left">-f 文件名</td><td align="left">如果文件存在且为普通文件则为真</td></tr><tr><td align="left">-c 文件名</td><td align="left">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td align="left">-b 文件名</td><td align="left">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><p>另外，Shell 还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为： ! 最高， -a 次之， -o 最低</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="/2024/11/06/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/11/06/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="几个常用命令"><a href="#几个常用命令" class="headerlink" title="几个常用命令"></a>几个常用命令</h2><table><thead><tr><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>ls</td><td>list</td><td>查看当前目录下的内容</td></tr><tr><td>pwd</td><td>print work directory</td><td>查看当前所在目录</td></tr><tr><td>cd [目录名]</td><td>change directory</td><td>切换目录</td></tr><tr><td>touch [文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>mkdir [目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>rm [文件名]</td><td>remove</td><td>删除指定文件</td></tr><tr><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><p><strong>注意：</strong>在执行Linux命令时，提示信息如果显示为乱码，则是由于编码问题导致，只需要修改Linux的编码即可，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;LANG=&quot;en_US.UTF-8&quot;&#x27;</span> &gt;&gt; /etc/profile<br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p><strong>使用技巧：</strong></p><ul><li>Tab键 自动补全</li><li>连按两次 Tab键 ，给出操作提示</li><li>使用 上下箭头 快速调出曾经使用过的命令</li><li>使用 clear命令 或者 Ctrl+l 快捷键实现清屏</li></ul><p><strong>Linux命令格式：</strong> command [-options] [parameter]，<strong>说明:</strong></p><ul><li>commanid：命令名</li><li>[-options]：选项，可用来对命令进行控制，也可以省略</li><li>[parameter]：传给命令的参数，可以是零个、一个或者多个</li><li>[] 代表可选</li><li>命令名、选项、参数之间有空格进行分隔</li></ul><h2 id="文件目录操作命令"><a href="#文件目录操作命令" class="headerlink" title="文件目录操作命令"></a>文件目录操作命令</h2><h3 id="显式指定目录下的内容：ls-al-dir"><a href="#显式指定目录下的内容：ls-al-dir" class="headerlink" title="显式指定目录下的内容：ls [-al] [dir]"></a>显式指定目录下的内容：ls [-al] [dir]</h3><ul><li><p>-a 显示所有文件及目录（.开头隐藏文件也会列出）</p></li><li><p>-l 除文件名称外，同时将文件型态（d表示目录，-表示文件）、权限、拥有者、文件大小等信息详细列出</p></li><li><p>ls -l 可简写为 ll</p></li></ul><h3 id="切换当前工作目录（进入指定目录）：cd-dirName"><a href="#切换当前工作目录（进入指定目录）：cd-dirName" class="headerlink" title="切换当前工作目录（进入指定目录）：cd [dirName]"></a>切换当前工作目录（进入指定目录）：cd [dirName]</h3><ul><li>~ 表示用户的home目录</li><li>. 表示目前所在的目录</li><li>.. 表示目前目录位置的上级目录（用的比较多）</li></ul><h3 id="用于显示文件内容：cat-n-fileName"><a href="#用于显示文件内容：cat-n-fileName" class="headerlink" title="用于显示文件内容：cat [-n] fileName"></a>用于显示文件内容：cat [-n] fileName</h3><ul><li>-n 由1开始对所有输出的行数编号</li><li>cat &#x2F;etc&#x2F;profile：查看&#x2F;etc目录下的profile文件内容</li></ul><h3 id="以分页的形式显示文件内容：more-fileName"><a href="#以分页的形式显示文件内容：more-fileName" class="headerlink" title="以分页的形式显示文件内容：more fileName"></a>以分页的形式显示文件内容：more fileName</h3><ul><li>回车键 向下滚动一行</li><li>空格键 向下滚动一屏</li><li>b 返回上一屏</li><li>q或者Ctrl+C 推出more</li></ul><h3 id="查看文件末尾的内容：tail-f-fileName"><a href="#查看文件末尾的内容：tail-f-fileName" class="headerlink" title="查看文件末尾的内容：tail [-f] fileName"></a>查看文件末尾的内容：tail [-f] fileName</h3><ul><li>-f 动态读取文件末尾内容并显示，通常用于日志文件的内输出</li><li>tail &#x2F;etc&#x2F;profile：显示&#x2F;etc目录下的profile文件末尾10行的内容</li><li>tail -20 &#x2F;etc&#x2F;profile：显示&#x2F;etc目录下的profile文件末尾20行的内容</li><li>tail -f &#x2F;itcast&#x2F;my.log：动态读取&#x2F;itcast目录下的my.log文件末尾内容并显示</li></ul><h3 id="创建目录：mkdir-p-dirName"><a href="#创建目录：mkdir-p-dirName" class="headerlink" title="创建目录：mkdir [-p] dirName"></a>创建目录：mkdir [-p] dirName</h3><ul><li>-p 确保目录名称存在，不存在就创建一个。通过此选项，可以实现多层目录同时创建</li><li>mkdir itcast：在当前目录下，建立一个名为itcast的子目录</li><li>mkdir -pitcast&#x2F;test：在工作目录下的itcast目录中建立一个名为test的子目录，若itcast目录不存在，则建立一个</li></ul><h3 id="删除空目录：rmdir-p-dirName"><a href="#删除空目录：rmdir-p-dirName" class="headerlink" title="删除空目录：rmdir [-p] dirName"></a>删除空目录：rmdir [-p] dirName</h3><ul><li>-p 当子目录被删除后使得父目录也为空目录的话，则一起删除</li><li>rmdir itcast 删除名为itcast的空目录</li><li>rmdir -pitcast&#x2F;test：删除itcast目录中名为test的子目录，若test目录删除后itcast目录变为空目录，则也被删除</li><li>rmdir itcast*：删除名称以itcast开始的空目录</li></ul><h3 id="删除文件或者目录：rm-rf-name"><a href="#删除文件或者目录：rm-rf-name" class="headerlink" title="删除文件或者目录：rm [-rf] name"></a>删除文件或者目录：rm [-rf] name</h3><ul><li>-r 将目录及目录中所有文件或目录逐一删除，即递归删除</li><li>-f 无需确认，直接删除</li><li>-r itcast&#x2F;：删除名为itcast的目录和目录中所有文件，删除前需确认</li></ul><h2 id="拷贝移动命令"><a href="#拷贝移动命令" class="headerlink" title="拷贝移动命令"></a>拷贝移动命令</h2><h3 id="用于复制文件或目录：cp-r-source-dest"><a href="#用于复制文件或目录：cp-r-source-dest" class="headerlink" title="用于复制文件或目录：cp [-r] source dest"></a>用于复制文件或目录：cp [-r] source dest</h3><ul><li>-r 如果复制的是目录需要，使用此选项，此时将复制该目录下的所有子目录和文件</li><li>cp hello.txt itcast&#x2F;：将hello.txt复制到itcast目录中</li><li>cp hello.txt .&#x2F;hi.txt：将hello.txt复制到当前目录，并改名为hi.txt</li><li>cp -r itcast&#x2F; .&#x2F;itheima&#x2F;：将itcast目录和目录下所有文件复制到itheima目录下</li><li>cp -r itcast&#x2F;* .&#x2F;itheima&#x2F;：</li></ul><h3 id="为文件或目录改名、或将文件或目录移动到其他位置：mv-source-dest"><a href="#为文件或目录改名、或将文件或目录移动到其他位置：mv-source-dest" class="headerlink" title="为文件或目录改名、或将文件或目录移动到其他位置：mv source dest"></a>为文件或目录改名、或将文件或目录移动到其他位置：mv source dest</h3><ul><li>mv hello.txt hi.txt：将hello.txt改名为hi.txt</li><li>mv hi.txt itheima&#x2F;：将文件hi.txt移动到itheima目录中</li><li>mv hi.txt itheima&#x2F;hello.txt：将hi.txt移动到itheima目录中，并改名为hello.txt</li><li>mv itcast&#x2F; itheima&#x2F;：如果itheima目录不存在，将itcast目录改名为itheima；如果itheima目录存在，将itcast目录移动到itheima目录中</li></ul><h2 id="打包压缩命令"><a href="#打包压缩命令" class="headerlink" title="打包压缩命令"></a>打包压缩命令</h2><h3 id="对文件进行打包、解包、压缩、解压：tar-zcxvf-fileName-包名-files-对哪些文件操作"><a href="#对文件进行打包、解包、压缩、解压：tar-zcxvf-fileName-包名-files-对哪些文件操作" class="headerlink" title="对文件进行打包、解包、压缩、解压：tar [-zcxvf] fileName(包名) [files] (对哪些文件操作)"></a>对文件进行打包、解包、压缩、解压：tar [-zcxvf] fileName(包名) [files] (对哪些文件操作)</h3><ul><li>包文件后缀为.tar表示只是完成了打包，并没有压缩</li><li>包文件后缀为.tar.gz表示打包的同时还进行了压缩</li></ul><table><thead><tr><th>选项</th><th>英文</th><th>作用</th></tr></thead><tbody><tr><td>-z</td><td>gzip</td><td>通过gzip命令处理文件，gzip可以对文件压缩或者解压</td></tr><tr><td>-c</td><td>create</td><td>创建新的包文件</td></tr><tr><td>-x</td><td>extract</td><td>实现从包文件中还原文件</td></tr><tr><td>-v</td><td>verbose</td><td>显示命令执行过程</td></tr><tr><td>-f</td><td>file</td><td>指定包文件的名称</td></tr></tbody></table><h2 id="文本编辑命令"><a href="#文本编辑命令" class="headerlink" title="文本编辑命令"></a>文本编辑命令</h2><h3 id="vi-fileName"><a href="#vi-fileName" class="headerlink" title="vi fileName"></a>vi fileName</h3><ul><li>vi命令是Linux系统提供的一个文本编辑工具，可以对文件内容进行编辑，类似于Windows中的记事本</li></ul><h3 id="vim-fileName"><a href="#vim-fileName" class="headerlink" title="vim fileName"></a>vim fileName</h3><ul><li><p>vim是从vi发展来的一个功能更加强大的文本编辑工具，在编辑文件时可以对文本内容进行着色，方便我们对文件进行编辑处理，所以实际工作中vim更加常用</p></li><li><p>要使用vim命令，需要我们自己完成安装。可以使用下面的命令来完成安装：yum install vim</p></li><li><p>在使用vim命令编辑文件时，如果指定的文件存在，则直接打开此文件，如果指定的文件不存在，则新建文件</p></li><li><p>vim在进行文本编辑时共分为三种模式，这三种模式之间可以相互切换，在使用vim时，一定要注意我们当前所处的是哪种模式：</p><ul><li>命令模式<ul><li>命令模式下可以查看文件内容、移动光标（上下左右箭头，gg：快速将光标移动到开头，G：快速将光标移动到末尾）</li><li>通过vim命令打开文件后，默认进入命令模式</li><li>另外两种模式需要先进入命令模式，才能进入彼此</li></ul></li><li>插入模式<ul><li>插入模式下可以对文件内容进行编辑</li><li>在命令模式下，按下i，a，o中的任意一个，可以进入插入模式，进入后，下方会出现 insert 字样</li><li>在插入模式下按下ESC键，回到命令模式</li></ul></li><li>底行模式<ul><li>底行模式下可以通过命令对文件内容进行查找、显示行号、退出等操作</li><li>在命令模式下，按下:，&#x2F;中的任意一个，可以进入底行模式</li><li>通过&#x2F;方式进入底行模式后，可以对文件内容进行查找</li><li>通过:方式进入底行模式后，可以输入wq（保存并退出）、q!（不保存退出）、set nu（显示行号）</li></ul></li></ul></li></ul><h2 id="查找命令"><a href="#查找命令" class="headerlink" title="查找命令"></a>查找命令</h2><h3 id="在指定目录下查找文件：find-dirName-option-fileName"><a href="#在指定目录下查找文件：find-dirName-option-fileName" class="headerlink" title="在指定目录下查找文件：find dirName -option fileName"></a>在指定目录下查找文件：find dirName -option fileName</h3><ul><li>-option一般是-name，即根据文件名称来找</li><li>find . -name “*.java”：在当前目录及其子目录下查找.java结尾文件</li><li>find &#x2F;itcast -name “*.java”：在&#x2F;itcast目录及其子目录下查找.java结尾的文件</li></ul><h3 id="从指定文件中查找指定的文本内容-grep-word-fileName"><a href="#从指定文件中查找指定的文本内容-grep-word-fileName" class="headerlink" title="从指定文件中查找指定的文本内容 grep word fileName"></a>从指定文件中查找指定的文本内容 grep word fileName</h3><ul><li>grep Hello Helloworld.java：查找HelloWorld.java文件中出现的Hello字符串的位置</li><li>grep hello *.java：查找当前目录中所有.java结尾的文件中包含hello字符串的位置</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
